/* $Revision: #3 $  (Pixar - RenderMan Division)       $Date: 2014/12/10 $ */
/*
# ------------------------------------------------------------------------------
#
# Copyright (c) 2006-2010 Pixar Animation Studios. All rights reserved.
#
# The information in this file (the "Software") is provided for the
# exclusive use of the software licensees of Pixar.  Licensees have
# the right to incorporate the Software into other products for use
# by other authorized software licensees of Pixar, without fee.
# Except as expressly permitted herein, the Software may not be
# disclosed to third parties, copied or duplicated in any form, in
# whole or in part, without the prior written permission of
# Pixar Animation Studios.
#
# The copyright notices in the Software and this entire statement,
# including the above license grant, this restriction and the
# following disclaimer, must be included in all copies of the
# Software, in whole or in part, and all permitted derivative works of
# the Software, unless such copies or derivative works are solely
# in the form of machine-executable object code generated by a
# source language processor.
#
# PIXAR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
# ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT
# SHALL PIXAR BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES
# OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
# WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
# ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
# SOFTWARE.
#
# Pixar
# 1200 Park Ave
# Emeryville CA 94608
#
# ------------------------------------------------------------------------------

*/

#ifndef RSLPLUGIN_H
#define RSLPLUGIN_H

// Use of typedefs like RtColor is recommended for new grid-based shadeops.
// For backwards compatibility, they are not automatically included for older
// pointwise shadeops.
#include "ri.h"
#include "RixInterfaces.h"      // RslContext inherits from RixContext
#include <stdarg.h>
#include <assert.h>
#include <string>

/// Plugin API version number.
#define RSL_PLUGIN_VERSION 7

/** 
    \file RslPlugin.h
    \mainpage RSL Plugin API Reference
    \brief The RslPlugin API allows shaders to call user-defined C++ code.

    The primary classes of the RslPlugin API are the following:
    - RslContext
    - RslArg
    - RslIter
    
    Here is a typical RSL plugin function, which computes "a = b + c"
    for floating-point values.
    \code
    RSLEXPORT int
    add(RslContext* rslContext, int argc, const RslArg** argv) {
        RslFloatIter a(argv[0]);
        RslFloatIter b(argv[1]);
        RslFloatIter c(argv[2]);

        int n = argv[0]->NumValues();
        for (int i = 0; i < n; ++i) {
            *a = *b + *c;
            ++a; ++b; ++c;      // Note: pre-incr is faster than post-incr.
        }
        return 0;
    }
    \endcode
    An iterator is conceptually a pointer that can be dereferenced to access a
    single value and incremented to reach the next value.  Grid data might be
    sparse, however; the increment operator knows how to skip to the next
    active point efficiently.

    An iterator can be used without regard to whether the argument data is
    uniform or varying: incrementing an iterator for a uniform argument has no
    effect.  The number of iterations is typically determined by the number of
    values in the result argument (argv[0]->NumValues()), which might be one
    if all the arguments are uniform.  Void plugin functions must take the
    detail of all the arguments into account, however:
    \code
        int n = RslArg::NumValues(argc, argv);
    \endcode
 
    An alternative interface is available for RSL plugin functions that require
    access to all the grid data (e.g. for block copies that might include
    data for inactive points).  Here is an example:
    \code
     RslArg* A = argv[0];
     RslArg* B = argv[1];
     RslArg* C = argv[2];
     float *aData, *bData, *cData;
     int aStride, bStride, cStride;
     A->GetData(&aData, &aStride);
     B->GetData(&bData, &bStride);
     C->GetData(&cData, &cStride);

     unsigned int numPoints;
     const RslRunFlag* runFlags = rslContext->GetRunFlags(&numPoints);
 
     for(int i = 0; i < numPoints; ++i) {
         if (runFlags[i])
             *aData = *bData + *cData;
         aData += aStride;
         bData += bStride;
         cData += cStride;
     }
    \endcode
    This implementation is far less efficient when grids are sparse.

*/

/// Most shadeops should use iterators to access data, but those that
/// don't use runflags to determine which grid points are active.
typedef unsigned int RslRunFlag;

/// Iterators use an accelaration structure involving small increments.
typedef unsigned int RslIncrType;

/// An RSL plugin function takes a context, number of arguments, and an array
/// of arguments.  A non-zero return value indicates an error.
typedef int (*RslEntryFunc)(class RslContext* ctx,
                            int argc, const class RslArg** argv);

/**
   The RslContext provides access to various capabilities required by shader
   plugins.  The context provides thread-safe global storage (via
   GetGlobalStorage()), per-thread storage (via GetThreadStorage()), and local
   "per-grid" storage (via GetLocalStorage()).  It also provides a
   general-purpose way to obtain RenderMan interface extensions
   (<a href="../RixInterfacesApi/index.html">RixInterface</a>), 
   which provide additional utilities, including error/warning messages with
   duplicate suppression 
   (<a href="../RixInterfacesApi/classRixMessages.html">RixMessages</a>),
   statistics (<a href="../RixInterfacesApi/classRixStats.html">RixStats</a>),
   and threading utilitis 
   (<a href="../RixInterfacesApi/classRixThreadUtils.html">RixThreadUtils</a>).
*/
class RslContext_v1 : public RixContext {
public:
    /// Virtual destructor
    virtual ~RslContext_v1() {}

    /// Returns an array of runflags. A value of 1 indicates the grid point
    /// is active, a value of 0 means the grid point is not active.
    virtual const RslRunFlag* GetRunFlags(unsigned int* length) const = 0;

    /// Shader plugins have access to 
    /// <a href="../RixInterfacesApi/index.html">RixInterfaces</a>
    /// that provide various kinds of storage management (per-frame,
    /// per-thread, and per-grid), statistics reporting, error messages, etc.
    virtual RixInterface* GetRixInterface(RixInterfaceId id) const = 0;

    /**
       Get thread-safe global variable storage
       (<a href="../RixInterfacesApi/classRixStorage.html">RixStorage</a>),
       which is used as follows:
       \code
       RixStorage* storage = rslContext->GetGlobalStorage();
       storage->Lock();
       void* myglobal = storage->Get("myglobal");
       if (myglobal == NULL) {
           myglobal = MakeData();
           storage->Set("myglobal", myglobal, CleanupData);
       }
       storage->Unlock();
       \endcode
       This code operates as follows:
       - Get the globals from the RslContext.
       - Lock the globals for thread safety.
       - Look up the key to see if the data already exists.
       - If not, allocate the data and store it in the globals.
         (The optional cleanup function is called at end of frame.)
       - Unlock the globals.
    */
    RixStorage* GetGlobalStorage() const
    {
        return (RixStorage*) GetRixInterface(k_RixGlobalData);
    }

    /**
       Get per-thread storage 
       (<a href="../RixInterfacesApi/classRixStorage.html">RixStorage</a>),
       which is used as follows:
       \code
       RixStorage* storage = rslContext->GetThreadStorage();
       void* mydata = storage->Get("mydata");
       if (mydata == NULL) {
           mydata = MakeData();
           storage->Set("mydata", mydata, CleanupData);
       }
       \endcode
       This code operates as follows:
       - Get the per-thread storage from the RslContext.
       - Look up the key to see if the data already exists.
       - If not, allocate the data and store it in the globals.
         (The optional cleanup function is called at end of frame.)
    */       
    RixStorage* GetThreadStorage() const
    {
        return (RixStorage*) GetRixInterface(k_RixThreadData);
    }

    /**
       Get local data storage
       (<a href="../RixInterfacesApi/classRixStorage.html">RixStorage</a>),
       which is cleared when the current shader set finishes running on the
       current set of points.
    */
    RixStorage* GetLocalStorage() const
    {
        return (RixStorage*) GetRixInterface(k_RixLocalData);
    }

    /// Set per-thread user data and optional cleanup function.
    /// The cleanup function is called on the user data when the thread
    /// is terminated.  For greater flexibility, use GetThreadStorage().
    void SetThreadData(void* data, RixCleanupFunc cleanup = 0L)
    {
        RixStorage* storage = (RixStorage*) GetRixInterface(k_RixThreadData);
        storage->Set(GetPluginName(), data, cleanup);
    }

    /// Get per-thread user data.
    void* GetThreadData() const
    {
        RixStorage* storage = (RixStorage*) GetRixInterface(k_RixThreadData);
        return storage->Get(GetPluginName());
    }

    /// Set local user data and optional cleanup function.
    /// The cleanup function is called on the user data when the current
    /// shader set finishes running on the current set of points.
    /// For greater flexibility, use GetLocalStorage().
    void SetLocalData(void* data, RixCleanupFunc cleanup = 0L)
    {
        RixStorage* storage = (RixStorage*) GetRixInterface(k_RixLocalData);
        storage->Set(GetPluginName(), data, cleanup);
    }

    /// Get local user data.
    void* GetLocalData() const
    {
        RixStorage* storage = (RixStorage*) GetRixInterface(k_RixLocalData);
        return storage->Get(GetPluginName());
    }

    /// Get the name of this plugin.
    virtual const char* GetPluginName() const = 0;

private:
    // Need to call private methods from iterator constructors.
    template<typename T> friend class RslIter;
    template<typename T> friend class RslArrayIter;

    // Get acceleration info for an iterator with "packed" user data.
    virtual RslIncrType* getIncrList(unsigned int stride) const = 0;
};

class RslContext_v2 : public RslContext_v1 {
public:
    /// Virtual destructor
    virtual ~RslContext_v2() {};

    /// Does this plugin execute in an environment where every
    /// 2nd and 3rd shading point is used to support ray
    /// footprints?
    virtual bool HasAuxiliaryPoints() const = 0;
};

class RslContext : public RslContext_v2 {
public:
    /// Virtual destructor
    virtual ~RslContext() {};
};

/// Plugin function argument (API version 2).  For internal use only.
/// User code should always use the most recent version, RslArg.
class RslArg_v2 {
public:
    /// Virtual destructor
    virtual ~RslArg_v2() {};

    /// Returns true if this argument is a float (or float array).
    virtual bool IsFloat() const = 0;

    /// Returns true if this argument is a point (or point array).
    virtual bool IsPoint() const = 0;

    /// Returns true if this argument is a vector (or vector array).
    virtual bool IsVector() const = 0;

    /// Returns true if this argument is a color (or color array).
    virtual bool IsColor() const = 0;

    /// Returns true if this argument is a string (or string array).
    virtual bool IsString() const = 0;

    /// Returns true if this argument is a matrix (or matrix array).
    virtual bool IsMatrix() const = 0;

    /// Returns true if this argument is an array.
    virtual bool IsArray() const = 0;

    /// Returns true if this argument is varying
    virtual bool IsVarying() const = 0;

    /// Get the length of an array argument.  The result is undefined
    /// if this argument is not an array (call IsArray() first).
    virtual int GetArrayLength() const = 0;

    /// Get the number of values for this argument.  Returns 1 if the
    /// argument is uniform.  Otherwise it returns the number of points
    /// in the context.
    virtual unsigned int NumValues() const = 0;

    /// Get the maximum number of values for the given arguments.
    /// This method should be used to determine the number of iterations
    /// when a plugin function returns values via output arguments.
    static unsigned int NumValues(int argc, const class RslArg** argv);

    /// Get the raw data pointer for this argument from the given context,
    /// along with the stride, which specifies how much to increment the
    /// pointer on each iteration.  (The stride is zero if the argument is
    /// uniform.)  Use with CAUTION!  Do not read or modify values for
    /// inactive points.  Use RslContext::GetRunflags to determine which
    /// points are active. NOTE: If the RslArg is an array, the stride 
    /// will not be the size of the array; use GetArrayLength() instead.
    virtual void GetData(float** data, int* stride) const = 0;

private:
    // Need to call private methods from iterator constructors.
    template<typename T> friend class RslIter;
    template<typename T> friend class RslArrayIter;

    // Returns (in result parameters) the data pointer and increment list.
    virtual void getInfo(float** data, RslIncrType** incrList,
                 bool* isVarying) const = 0;

    // Returns (in result parameters) the data pointer, increment list, and
    // array length.
    virtual void getArrayInfo(float** data,
                      RslIncrType** incrList, int* arrayLength,
                      bool* isVarying) const = 0;
};


/// Plugin function argument (API version 3).  For internal use only.
/// User code should always use the most recent version, RslArg.
class RslArg_v3 : public RslArg_v2
{
public:
    /// Returns true if this argument is a normal (or normal array).
    virtual bool IsNormal() const = 0;

    /// Returns true if this argument is writeable.  This is useful in 
    /// varargs plugin functions to verify that output arguments are valid.
    /// An argument is writeable if it's a local variable, a shader output
    /// parameter, or a global variable (e.g. P, N).
    virtual bool IsWriteable() const = 0;

    /// Virtual destructor
    virtual ~RslArg_v3() {};
};


/// Plugin function argument (API version 5).  For internal use only.
/// User code should always use the most recent version, RslArg.
class RslArg_v5 : public RslArg_v3
{
public:
    /// Returns true if this argument is a struct (or struct array).
    virtual bool IsStruct() const = 0;

    /// Get the name of this argument, which is not guaranteed to be sensible.
    /// Useful for error messages and struct member handling.
    virtual const char* GetName() const = 0;

    /// Returns true if this argument is a resizable array.
    virtual bool IsResizable() const = 0;

    /// Get resizer for this argument (returns NULL if not resizable).
    virtual class RslResizer* GetResizer() const = 0;

    /// Virtual destructor
    virtual ~RslArg_v5() {};

private:
    // Need to call private methods from various constructors.
    friend class RslStruct;
    friend class RslStructArray;
    template<typename T> friend class RslArrayIter;


    // Get struct data pointer, along with array length and stride.
    virtual float* getStructData(int* length,
                                 unsigned int* stride) const = 0;

    // Get struct info.  Returns RslArgs for struct members.
    virtual const RslArg** getStructInfo(float* data,
                                         const char** name, 
                                         unsigned int* numMembers) const = 0;

    // OBSOLETE: The layout of array data has changed in version 5.
    // Returns (in result parameters) the data pointer, increment list, and
    // array length/capacity.
    virtual void getArrayInfo(float** data,
                              RslIncrType** incrList, int* arrayLength,
                              int* arrayCapacity, bool* isVarying) const = 0;

    // Obsolete version of getArrayInfo, which doesn't return capacity.
    virtual void getArrayInfo(float** data,
                              RslIncrType** incrList, int* arrayLength,
                              bool* isVarying) const = 0;
};

// NOTE:
//    This is a shim class to provide compatabiliy with
//    v5 of the RslArg interface. Due to a cut/paste
//    error in a previous release, some private methods 
//    from RslArg_v5 were aliased against the actual
//    RslArg interface.
class RslArg_v6 : public RslArg_v5
{
public:
    /// Virtual destructor
    virtual ~RslArg_v6() {};

    // Note these are the actual methods that were resolved
    // instead of the ones defined in RslArg_v5
private:
    // Need to call private methods from various constructors.
    friend class RslStruct;
    friend class RslStructArray;
    template<typename T> friend class RslArrayIter;

    // Returns (in result parameters) the data pointer, increment list, and
    // array length/capacity and element stride.
    virtual void getArrayInfo(float **data, 
                              RslIncrType ** incrList, int* arrayLength, 
                              int* arrayCapacity,  int* elemStride,
                              bool* isVarying) const = 0;

    // OBSOLETE: The layout of array data has changed in version 5.
    virtual void getArrayInfo(float** data,
                              RslIncrType** incrList, int* arrayLength,
                              int* arrayCapacity, bool* isVarying) const = 0;

    // Obsolete version of getArrayInfo, which doesn't return capacity.
    virtual void getArrayInfo(float** data,
                              RslIncrType** incrList, int* arrayLength,
                              bool* isVarying) const = 0;
};

/// Plugin function argument (API version 7).  For internal use only.
/// User code should always use the most recent version, RslArg.
class RslArg_v7 : public RslArg_v6
{
public:

    /// Returns true if this argument is a filter region.
    virtual bool IsFilterRegion() const = 0;

    /// Virtual destructor
    virtual ~RslArg_v7() {};
};

/**
   An array of RslArg pointers is passed to the RSL plugin function.  The
   result parameter is always the zeroth argument (even in a void function).

   Various methods can be used to query the type of an RslArg (e.g. IsFloat(),
   IsArray()), its detail (IsVarying()), and other information
   (GetArrayLength(), IsWriteable()).

   An iterator (RslIter) must be constructed to access the data represented by
   an RslArg.  The type of iterator depends on the underlying data type.
   For example:
   \code
       assert(argv[0].IsFloat());
       assert(argv[1].IsArray() && argv[1].IsColor());
       RslFloatIter num(argv[0]);
       RslColorArrayIter colors(argv[1]);
   \endcode

   If an argument might be varying, the NumValues() method is used to determine
   the number of iterations required to process it.  Any arguments that are
   varying require the same number of iterations.  If the function returns a
   result (i.e. does not have a void return type), the shader compiler
   guarantees that the result argument (argv[0]) is varying whenever any of
   the other arguments are varying.  It's usually sufficient to use 
   "argv[0]->NumValues()" as the required number of iterations.  For example:
   \code
        int n = argv[0]->NumValues();
        for (int i = 0; i < n; ++i) {
            *a = *b + *c;
            ++a; ++b; ++c;
        }
   \endcode
   Void plugin functions must take the detail of all the arguments into
   account, however:
   \code
       int n = RslArg::NumValues(argc, argv);
   \endcode

   Note that incrementing an iterator for a uniform argument has no effect.
   Also, the number of iterations might be one if all the arguments are
   uniform.  In our experience, it is usually not worth optimizing for such
   cases.  If performance is a concern, overloading can be used to define a
   specialized plugin function that operates on all uniform arguments.
*/
class RslArg : public RslArg_v7
{
public:
    /// Virtual destructor
    virtual ~RslArg() {};

};


// Implementation of RslArg_v2::NumValues must follow definition of RslArg.
inline unsigned int 
RslArg_v2::NumValues(int argc, const RslArg** argv) 
{
    int m = 1;
    for (int i = 0; i < argc; ++i) {
        int n = argv[i]->NumValues();
        if (n > m)
            m = n;
    }
    return m;
}


/**
    An iterator is used to access grid data.  Incrementing an iterator skips
    over inactive grid points.  An iterator is constructed from an RslArg
    and used as follows:
    \code
    RslFloatIter a(argv[0]);
    RslFloatIter b(argv[1]);
    RslFloatIter c(argv[2]);

    int n = argv[0]->NumValues();
    for (int i = 0; i < n; ++i) {
        *a = *b + *c;
        ++a; ++b; ++c;
    }
    \endcode

    Run-time type assertions are recommended to guard against inadvert type
    errors:
    \code
    assert(argv[0].IsFloat());
    \endcode
    This should be unnecessary because the shader compiler guarantees that the
    argument values match the parameter types specified in the plugin function
    prototype (in the RslFunctionTable).  However, type assertions guard
    against inadvertent prototype errors, and they help catch errors in
    overloaded functions that can otherwise be difficult to diagnose.
*/
template<typename T>
class RslIter {
public:
    /// Construct an iterator from an argument.
    RslIter(const RslArg* arg)
    {
        arg->getInfo(&m_data, &m_incrList, &m_isVarying);
        m_dataStart = m_data;
        m_incrListStart = m_incrList;
    }

    /// Construct a uniform iterator for user-provided data.
    /// This is useful for optional arguments with default values.
    RslIter(const T* data, const RslContext* ctx) :
        m_data((float*) data),
        m_dataStart((float*) data),
        m_incrList(ctx->getIncrList(0)),
        m_incrListStart(ctx->getIncrList(0)),
        m_isVarying(false)
    {
    }

    /// Dereference this iterator, yielding a non-const reference.  This
    /// method is automatically selected when a dereferenced iterator is
    /// the target of an assignment, such as "*a = 0".
    T& operator*() { return *((T*) m_data); }

    /// Get a const reference to the data pointed to by this iterator.
    /// This method is automatically selected by the compiler when
    /// appropriate.
    const T& operator*() const { return *((T*) m_data); }

    /// Increment this iterator to point to the data for the next active
    /// point.  An internal acceleration structure makes this a
    /// constant-time operation.
    RslIter<T>& operator++() 
    {
        m_data += *m_incrList;
        ++m_incrList;
        return *this;
    };

    /// Post-increment this iterator.  Returns a copy of the iterator
    /// prior to incrementing, so it's not terribly efficient.  The dummy
    /// integer argument is the standard C++ way of distinguishing between
    /// pre- and post-increment operators.
    RslIter<T> operator++(int) 
    {
        RslIter<T> temp = *this;                // Copy before increment.
        ++*this;                        // Increment.
        return temp;                    // Return old value.
    };

    /// Reset the iterator to point at the first active point.
    void Reset()
    {
        m_data = m_dataStart;
        m_incrList = m_incrListStart;
    }

    /// Returns true if the iterator is varying.  Note that uniform iterators
    /// need not be incremented (although it does no harm).
    bool IsVarying() const { return m_isVarying; }

private:
    // Current data pointer.
    float* m_data;

    // The reset to the start data pointer.
    float* m_dataStart;

    // Current increment list, which gives fast access to next active point.
    RslIncrType* m_incrList;

    // The reset to the start increment list pointer.
    RslIncrType* m_incrListStart;

    // True if the iterator is varying.
    bool m_isVarying;
};
    

/// Increment operator for matrices must scale the increment.
template<>
inline RslIter<RtMatrix>&
RslIter<RtMatrix>::operator++() 
{
    m_data += *m_incrList * 16;
    ++m_incrList;
    return *this;
}


/**
   An iterator for array arguments.  The length of an array is always uniform,
   and it can be obtained either from the iterator or the RslArg.  

   We recommend indexing an array iterator using operator[] rather than
   dereferencing the iterator.  Dereferencing the iterator returns a pointer
   to the first array element, and indexing errors can arise if that pointer
   is not declared with the correct type. Also in API version 6, the layout
   of array data in memory has been transposed for improved cache performance.
   To avoid runtime errors in existing code, the dereference operator for 
   array iterators has been conditionally disabled. It can be re-enabled by 
   defining the RSL_ALLOW_ARRAY_DEREF flag.

   Here is an example that demonstrates how arrays are typically used.  It is
   a plugin function that computes the average value in an array of colors.
   Note the colors might be varying, so a doubly nested loop is required.
   \code
     RSLEXPORT 
     int averageColor(RslContext* rslContext, int argc, const RslArg** argv) {
         assert(argv[0]->IsColor());
         assert(argv[1]->IsColor() && argv[1]->IsArray());
         RslColorIter result(argv[0]);
         RslColorArrayIter colors(argv[1]);
         int numColors = colors.GetLength();
     
         int n = argv[0]->NumValues();
         for (int i = 0; i < n; ++i) {
             RtColor avg = {0.0f, 0.0f, 0.0f};
             for (int j = 0; j < numColors; ++j) {
                 // Note that we index the array iterator using operator[].
                 RtColor& c = colors[j];
                 avg[0] += c[0];
                 avg[1] += c[1];
                 avg[2] += c[2];
             }
             (*result)[0] = avg[0] / numColors;
             (*result)[1] = avg[1] / numColors;
             (*result)[2] = avg[2] / numColors;
     
             // Increment iterators
             ++result;
             ++colors;
         }
         return 0;
     }
    \endcode
*/
template<typename T>
class RslArrayIter {
public:
    /// Construct an array iterator from an argument.
    RslArrayIter(const RslArg* arg)
    {
        arg->getArrayInfo(&m_data, &m_incrList, &m_length, &m_capacity, 
                          &m_stride, &m_isVarying);

        m_dataStart = m_data;
        m_incrListStart = m_incrList;
    }

    /// Construct a uniform array iterator for user-provided data.
    /// This is useful for optional arguments with default values.
    RslArrayIter(const T* data, int length, const RslContext* ctx) :
        m_data((float*) data),
        m_dataStart((float*) data),
        m_incrList(ctx->getIncrList(0)),
        m_incrListStart(ctx->getIncrList(0)),
        m_length(length),
        m_capacity(length),
        m_stride(1),
        m_isVarying(false)
    {
    }

    // Default constructor
    RslArrayIter() :
        m_data(NULL),
        m_dataStart(NULL),
        m_incrList(NULL),
        m_incrListStart(NULL),
        m_length(0),
        m_capacity(0),
        m_stride(0),
        m_isVarying(false)
    { 
    }

    /// The array index operator can be used to access individual
    /// array members.
    T&  operator[](int x) 
    {
        assert(x >= 0 && x < m_length);
        return ((T*)m_data)[x * m_stride]; 
    }

    /// Increment this iterator to point to the next active point
    /// of the current array element. An internal acceleration 
    /// structure makes this a constant-time operation.
    RslArrayIter<T>& operator++() 
    {
        m_data += *m_incrList;
        ++m_incrList;
        return *this;
    };

    /// Post-increment this iterator.  Returns a copy of the iterator
    /// prior to incrementing, so it's not terribly efficient.  The dummy
    /// integer argument is the standard C++ way of distinguishing between
    /// pre- and post-increment operators.
    RslArrayIter<T> operator++(int) 
    {
        RslArrayIter<T> temp = *this;   // Copy before increment.
        ++*this;                        // Increment.
        return temp;                    // Return old value.
    }; 
    
    /// Reset the iterator to point at the first active point.
    /// By default reset the the first array element. Optionally
    /// reset to the first active point of a given array index.
    void Reset(int index=0)
    {
        m_data = (float *)&((T*)m_dataStart)[index * m_stride];
        m_incrList = m_incrListStart;
    }
 
    /// Returns true if the iterator is varying.  Note that uniform iterators
    /// need not be incremented (although it does no harm).
    bool IsVarying() const { return m_isVarying; }

    /// Returns the array length.
    int GetLength() const { return m_length; }
        
    /// Returns the array capacity.
    int GetCapacity() const { return m_capacity; }

    /// Returns the array element stride.
    int GetStride() const { return m_stride; }

#ifndef RSL_ALLOW_ARRAY_DEREF
private:
#endif
    /// Dereference this iterator, yielding a pointer to the start
    /// of the array.
    T* operator*() { return (T*) m_data; }
        
private:
    // Current data pointer.
    float* m_data;

    // The reset to the start data pointer.
    float* m_dataStart;

    // Current increment list, which gives fast access to next active point.
    RslIncrType* m_incrList;

    // The reset to the start increment list pointer.
    RslIncrType* m_incrListStart;

    // Array length.
    int m_length;

    // Array capacity, which is the same as the length unless it's resizable.
    int m_capacity;

    // The stride to get to the next array element
    int m_stride;

    // True if the iterator is varying.
    bool m_isVarying;
};

/// Increment operator for matrices must scale the increment.
template<>
inline RslArrayIter<RtMatrix>&
RslArrayIter<RtMatrix>::operator++() 
{
    m_data += *m_incrList * 16;
    ++m_incrList;
    return *this;
}

typedef RslIter<RtFloat>        RslFloatIter;        ///< Float iterator
typedef RslIter<RtString>       RslStringIter;       ///< String iterator
typedef RslIter<RtColor>        RslColorIter;        ///< Color iterator
typedef RslIter<RtVector>       RslVectorIter;       ///< Vector iterator
typedef RslIter<RtNormal>       RslNormalIter;       ///< Normal iterator
typedef RslIter<RtPoint>        RslPointIter;        ///< Point iterator
typedef RslIter<RtMatrix>       RslMatrixIter;       ///< Matrix iterator
typedef RslIter<RtMatrix>       RslFilterRegionIter; ///< FilterRegion iterator
                                                     // data layout as RtMatrix

typedef RslArrayIter<RtFloat>   RslFloatArrayIter;   ///< Float array iterator
typedef RslArrayIter<RtString>  RslStringArrayIter;  ///< String array iterator
typedef RslArrayIter<RtColor>   RslColorArrayIter;   ///< Color array iterator
typedef RslArrayIter<RtVector>  RslVectorArrayIter;  ///< Vector array iterator
typedef RslArrayIter<RtNormal>  RslNormalArrayIter;  ///< Normal array iterator
typedef RslArrayIter<RtPoint>   RslPointArrayIter;   ///< Point array iterator
typedef RslArrayIter<RtMatrix>  RslMatrixArrayIter;  ///< Matrix array iterator

/** 
    A resizable array can be manipulated using an RslResizer object.
    The following example demonstrates how to push and pop
    values on a resizable array (which might or might not be varying).
    \code
    int Push(RslContext* ctx, int argc, const RslArg** argv)
    {
        assert(argv[1]->IsResizable());
        RslResizer* resizer = argv[1]->GetResizer();
        unsigned int oldLength = resizer->GetLength();
        resizer->Resize(oldLength+1);
    
        RslFloatArrayIter array(argv[1]);
        RslFloatIter arg(argv[2]);
        unsigned int numPoints = argv[1]->NumValues();
        for (int i = 0; i < numPoints; ++i) {
            array[oldLength] = *arg;
            ++array;
            ++arg;
        }
        return 0;
    }
    
    int MyPop(RslContext* ctx, int argc, const RslArg** argv)
    {
        assert(argv[1]->IsResizable());
        RslFloatIter result(argv[0]);
        assert(argv[1]->IsArray() && argv[1]->IsFloat());
        RslFloatArrayIter array(argv[1]);
        unsigned int n = array.GetLength()-1;
        unsigned int numPoints = argv[0]->NumValues();
        for (int i = 0; i < numPoints; ++i) {
            *result = array[n];
            ++result;
            ++array;
        }
        RslResizer* resizer = argv[1]->GetResizer();
        resizer->Resize(n);
        return 0;
    }
    \endcode

    Resizing an array might invalidate an existing array iterator, so beware.
    In addition to the Resize() method, a Reserve() method is also available.
    This allows the capacity of a an arry to be increased without changing
    its length, which amortizes allocation costs when pushing multiple values.
*/
class RslResizer {
public:
    /// Get the current length.
    virtual unsigned int GetLength() const = 0;

    /// Get the current capacity.
    virtual unsigned int GetCapacity() const = 0;

    /// Resize this array, copying the existing array elements if necessary.
    /// If the length is increased, the new elements are uninitialized.
    /// Resizing an array increases its capacity if necessary. However,
    /// reducing the length does not decrease the capacity (unless it is set
    /// to zero, in which case the storage is reclaimed).
    virtual void Resize(unsigned int n) = 0;

    /// Reserve storage, increasing the capacity of the array without changing
    /// its length.  This is useful when pushing multiple values to amortize
    /// allocation costs.  Specifying a value lower than the current capacity
    /// has no effect, unless it is reduced to zero, in which case storage is
    /// reclaimed.
    virtual void Reserve(unsigned int n) = 0;

protected:
    /// Destructor is for internal use only.
    virtual ~RslResizer() { }
};


/** 
    An RslStruct represents a struct value.  See the 
    <a href="../StructsInRSL.html">"Structs in RSL"</a>
    application note for more information.

    An RslStruct is constructed from an RslArg.  An RslStruct can be used like
    an array of RslArg, using an index operator to obtain the RslArg for each
    struct member.  Each of those can in turn be used to construct an iterator
    to access the data.  For example, a struct containing a float and a color
    can be used as follows:
    \code
        RslArg* structArg = argv[1];
        RslStruct structure(structArg);
        const RslArg* floatArg = structure[0];
        const RslArg* colorArg = structure[1];
        RslFloatIter f(floatArg);
        RslColorIter c(colorArg);
    \endcode
    or more concisely,
    \code
        RslStruct structure(argv[1]);
        RslFloatIter f(structure[0]);
        RslColorIter c(structure[1]);
    \endcode

    Unless it is overloaded, a plugin function usually knows the types of its
    arguments.  The shader compiler's typechecker ensures that its arguments
    always match its function prototype.

    Nevertheless, it is sometimes useful to "introspect" a struct type.  This
    is especially helpful for detecting "version skew", which might arise if a
    member is added to a struct definition without making corresponding
    modifications to plugins that depend upon it.

    An RslStruct provides a GetName() method that returns the struct type
    name.  The GetNumMembers() method returns the number of members.
    Information about the struct members is obtained from their RslArg objects
    using the usual type and detail queries (e.g. IsFloat(), IsStruct(),
    IsArray(), GetArrayLength(), IsVarying()).  In addition, RslArg provides a
    GetName() method that returns the name of a struct member.
*/
class RslStruct {
public:
    /// Construct an RslStruct from an RslArg.
    RslStruct(const RslArg* arg)
    {
        assert(arg->IsStruct() && !arg->IsArray());
        int length;
        unsigned int stride;
        float* data = arg->getStructData(&length, &stride);
        m_members = arg->getStructInfo(data, &m_name, &m_numMembers);
    }

    /// Get the type name.
    const char* GetName() const { return m_name; }

    /// Get the number of struct members.
    unsigned int GetNumMembers() const { return m_numMembers; }

    /// Returns an RslArg for the specified struct member.
    const RslArg* operator[](int i) const
    {
        assert(i >= 0 && (unsigned int) i < m_numMembers); 
        return m_members[i];
    }

private:
    // Struct members
    const RslArg** m_members;

    // Struct type name.
    const char* m_name;

    // Number of struct members.
    unsigned int m_numMembers;

    // RslStructArray calls a private constructor.
    friend class RslStructArray;

    // Private constructor
    RslStruct(const RslArg* arg, float* data)
    {
        m_members = arg->getStructInfo(data, &m_name, &m_numMembers);
    }
};


/** 
    An RslStructArray represents an array of structs.  It provides an indexing
    operator that returns an RslStruct.  For example:
    \code
        RslStructArray array(argv[1]);
        int arrayLength = array.GetLength();
        for (int i = 0; i < arrayLength; ++i) {
            RslStruct structure(array[i]);
            const RslArg* floatMember = structure[0];
            RslFloatIter f(floatMember);
            int n = floatMember->NumValues();
            for (int j = 0; j < n; ++j) {
                ...
            }
        }
    \endcode        
*/
class RslStructArray {
public:
    /// Construct an RslStructArray from an RslArg.
    RslStructArray(const RslArg* arg)
    {
        assert(arg->IsArray() && arg->IsStruct());
        m_array = arg;
        m_data = arg->getStructData(&m_length, &m_stride);
    }

    /// Get the specified element of this struct array.
    RslStruct operator[](int i) const
    {
        assert(i >= 0 && i < m_length);
        return RslStruct(m_array, m_data + i * m_stride);
    }

    /// Returns the array length.
    int GetLength() const { return m_length; }

private:
    // RslArg that represents the array.
    const RslArg* m_array;

    // Data pointer.
    float* m_data;

    // Array length.
    int m_length;

    // Stride for array index calculations (in words)
    unsigned int m_stride;
};


/// A per-frame init/cleanup function takes a
/// <a href="../RixInterfacesApi/classRixContext.html">RixContext</a>, 
/// which allows it to obtain interfaces for reporting errors, accessing
/// global RixStorage, etc.
typedef void (*RslVoidFunc)(RixContext* context);

/**
    Each plugin must define an RSL function table, which requires two steps.
    First, a array of RslFunction structs is defined:
    \code
        static RslFunction myfunctions[] = {
            { "float sqr(float)", sqr_f, NULL, NULL, NULL, NULL },
            { "color sqr(color)", sqr_c, NULL, NULL, NULL, NULL },
            { "point mynoise(point)", mynoise, noiseinit, noisedelete, NULL, NULL },
            NULL
        };
    \endcode
    An RslFunctionTable called "RslPublicFunctions" must be constructed
    from this array of structs:
    \code
    RSLEXPORT RslFunctionTable RslPublicFunctions(myfunctions);
    \endcode

    Each RslFunction specifies the prototype(s) of a shadeop, along a pointer
    to its entry function.  Overloaded shadeops have multiple entries with
    different prototypes (which might share the same entry point since colors,
    points, and vectors have the same representation).  The last entry of the
    array should be NULL.

    Each RslFunction can also have an optional associated init and cleanup
    function. The init function is called once per frame in a thread safe way
    for EACH function it is associated with. Likewise each cleanup function is
    called once at the end of frame for EACH associated function. The cleanup
    function will ONLY be called for a function with an associated init
    function.

    In addition to the init and cleanup functions. each RslFunction can also have
    an optional renderBegin and renderEnd function.
    The renderBegin function is called once in a thread safe way when rendering
    starts (including a re-endering iteration).  They are called for EACH associated
    function. Each renderEnd function is called once at the end of a render iteration.
    The renderBegin and renderEnd functions will ONLY be called for a function with an
    associated init function and if that init function has already been called.
    They provide an opportunity to check the validity of external resources during
    re-rendering.
*/
struct RslFunction {
    /// RSL function prototype.
    const char *m_prototype;

    /// Pointer to entry function.
    RslEntryFunc m_entry;

    /// Per-frame initialization function (possibly NULL).
    RslVoidFunc m_initFunc;

    /// Per-frame cleanup function (possibly NULL).
    RslVoidFunc m_cleanupFunc;
    
    /// Per-render function (possibly NULL).
    RslVoidFunc m_renderBeginFunc;
    
    /// Per-render function (possibly NULL).
    RslVoidFunc m_renderEndFunc;
};

/**
    Each plugin should define an RslFunctionTable called "RslPublicFunctions".  
    It is constructed from an arry of RslFunction structs.  In addition to
    specifying the array of entry functions, an optional initialization and
    cleanup function may be provided:
    \code
    RSLEXPORT 
    RslFunctionTable RslPublicFunctions(myfunctions,
                                        myinit, mycleanup);
    \endcode
    The initialization function is executed the first time any function in the
    pluginis called in a given frame, and the cleanup function is called at
    the end of the frame.

    The plugin table MUST be declared with PRMANEXPORT.  For
    example:
    \code
       PRMANEXPORT RslFunction RslPublicFunctions = ...
    \endcode
    RSLEXPORT was the old way of declaring this, and is still
    available for backwards compatability
*/
struct RslFunctionTable {
    /// The function table.
    const RslFunction* m_functions;

    /// Plugin API version number (for internal use only).
    const char m_version;

    /// Per-frame initialization function (possibly NULL).
    RslVoidFunc m_initFunc;

    /// Per-frame cleanup function (possibly NULL).
    RslVoidFunc m_cleanupFunc;

    /// Constructor
    RslFunctionTable(const RslFunction* functions,
                     RslVoidFunc init = NULL, RslVoidFunc cleanup = NULL) :
        m_functions(functions),
        m_version(RSL_PLUGIN_VERSION),
        m_initFunc(init),
        m_cleanupFunc(cleanup)
    {
    }
};

#endif /* defined RSLPLUGIN_H */
