#ifndef RixColorUtils_h
#define RixColorUtils_h
/* $Revision: #2 $ $Date: 2014/12/10 $
# ------------------------------------------------------------------------------
#
# Copyright (c) 2012-2014 Pixar Animation Studios. All rights reserved.
#
# The information in this file (the "Software") is provided for the
# exclusive use of the software licensees of Pixar.  Licensees have
# the right to incorporate the Software into other products for use
# by other authorized software licensees of Pixar, without fee.
# Except as expressly permitted herein, the Software may not be
# disclosed to third parties, copied or duplicated in any form, in
# whole or in part, without the prior written permission of
# Pixar Animation Studios.
#
# The copyright notices in the Software and this entire statement,
# including the above license grant, this restriction and the
# following disclaimer, must be included in all copies of the
# Software, in whole or in part, and all permitted derivative works of
# the Software, unless such copies or derivative works are solely
# in the form of machine-executable object code generated by a
# source language processor.
#
# PIXAR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
# ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT
# SHALL PIXAR BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES
# OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
# WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
# ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
# SOFTWARE.
#
# Pixar
# 1200 Park Ave
# Emeryville CA 94608
#
# ------------------------------------------------------------------------------
*/


#include "RixInterfaces.h"

/*
 * Routines to convert a triple from some color space into RGB.  RGB means
 * NTSC RGB whenever it matters (such as in YIQ, XYZ, xyY).  In the HSV, HSL
 * cases, the color space is defined in terms of RGB so it really doesn't
 * matter what RGB space you are really using!
 *
 * All of these routines assume that the input and output triples may refer
 * to the same location in memory.
 */

/*
 * RixHsvToRgb(hsv, rgb) converts a hue/saturation/value triple into an
 * RGB triple.
 * Based on the "hexcone" model.  See A.R.Smith, Color Gamut Transform Pairs,
 * Proc. Siggraph '78.
 */
#define IFLOOR(x)	(((x)<0.0f && (x)!=(int)(x))?(int)x-1:(int)x)


PRMAN_INLINE void
RixHsvToRgb(RtColorRGB const &hsv, RtColorRGB &rgb)
{
	RtFloat h, f;
	RtFloat m, n, k;
	int i;

	h = hsv.r;
	h = h - (int)h + (h < 0.0f ? 1.0f : 0.0f);	/* h mod 1.0 */
	h = h * 6.0f;
	i = IFLOOR(h);			/* integer part */
	f = h - i;			/* fractional part */
	m = hsv.b * (1.0f - hsv.g);
	n = hsv.b * (1.0f - (hsv.g * f));
	k = hsv.b * (1.0f - (hsv.g * (1.0f - f)));

	switch (i) {	/* around the color wheel */
	case 0:
		rgb.r = hsv.b;
		rgb.g = k;
		rgb.b = m;
		break;
	case 1:
		rgb.r = n;
		rgb.g = hsv.b;
		rgb.b = m;
		break;
	case 2:
		rgb.r = m;
		rgb.g = hsv.b;
		rgb.b = k;
		break;
	case 3:
		rgb.r = m;
		rgb.g = n;
		rgb.b = hsv.b;
		break;
	case 4:
		rgb.r = k;
		rgb.g = m;
		rgb.b = hsv.b;
		break;
	case 5:
		rgb.r = hsv.b;
		rgb.g = m;
		rgb.b = n;
	}
}

PRMAN_INLINE void
RixRgbToHsv(RtColorRGB const &rgb, RtColorRGB &hsv)
{
	int spoke;	/* part of color wheel it's in */
	RtFloat h,s,v;	/* hue, saturation & value components of HSV */
	RtFloat x;	/* smallest RGB component */

	/* set v to largest rgb component, x to smallest */
	if (rgb.r > rgb.g) {
		if (rgb.r > rgb.b) {
			v = rgb.r;
			spoke = 0;
		} else {
			v = rgb.b;
			spoke = 4;
		}
		if (rgb.g < rgb.b) {
			x = rgb.g;
			spoke++;
		} else {
			x = rgb.b;
		}
	} else {
		if (rgb.g > rgb.b) {
			v = rgb.g;
			spoke = 2;
		} else {
			v = rgb.b;
			spoke = 4;
		}
		if (rgb.r < rgb.b) {
			x = rgb.r;
		} else {
			x = rgb.b;
			spoke++;
		}
	}

	h = 0.0f;		/* default hue is red */
	s = 0.0f;		/* default saturation is unsaturated (gray) */
	if (v < 0.0001f)	/* black */
		goto done;

	s = (v - x)/v;		/* actual saturation */
	if (s < 0.0001f)	/* gray */
		goto done;

	/* now compute actual hue */
	switch (spoke) {
	case 0:		/* red largest, blue smallest */
		h = 1.0f - (v - rgb.g)/(v - x);
		break;

	case 1:		/* red largest, green smallest */
		h = 5.0f + (v - rgb.b)/(v - x);
		break;

	case 2:		/* green largest, red smallest */
		h = 3.0f - (v - rgb.b)/(v - x);
		break;

	case 3:		/* green largest, blue smallest */
		h = 1.0f + (v - rgb.r)/(v - x);
		break;

	case 4:		/* blue largest, red smallest */
		h = 3.0f + (v - rgb.g)/(v - x);
		break;

	case 5:		/* blue largest, green smallest */
		h = 5.0f - (v - rgb.r)/(v - x);
		break;
	}
done:
	hsv.r = h * (1.0f/6.0f);
	hsv.g = s;
	hsv.b = v;
}

/*
 * RixHslToRgb(hsl, rgb) converts a color in hue/saturation/lightness space into
 * an RGB triple.
 *
 * Based on the HLS color model.  See Foley and Van Dam, "Fundamentals of
 * Interactive Computer Graphics", 1982.
 *
 * RixHslToRgb assumes h is in the range [0,1) instead of [0,360) as defined
 * in Foley and Van Dam.
 */

// private function
PRMAN_INLINE RtFloat
rixValue(RtFloat n1, RtFloat n2, RtFloat hue)
{
	/* hue = hue mod 1.0 */
	hue = hue - (int)hue + (hue < (float)0.0 ? (float)1.0 : (float)0.0);
	if (hue < (float)0.16666667)
		return(n1 + (n2 - n1)*hue*(float)6.0);
	if (hue < (float)0.5)
		return(n2);
	if (hue < (float)0.66666667)
		return(n1 + (n2 - n1)*((float)4.0 - hue*(float)6.0));
	return (n1);
}

PRMAN_INLINE void
RixHslToRgb(RtColorRGB const &hsl, RtColorRGB &rgb)
{
	RtFloat	h, s, l;
	RtFloat m1, m2;

	h = hsl.r; s = hsl.g; l = hsl.b;

	if (s == 0.0f) {
		rgb.r = rgb.g = rgb.b = l;
		return;
	}

	if (l <= 0.5f)
		m2 = l*(1.0f + s);
	else
		m2 = l + s - l*s;
	m1 = 2.0f*l - m2;

	rgb.r = rixValue(m1, m2, h+0.33333333f);
	rgb.g = rixValue(m1, m2, h);
	rgb.b = rixValue(m1, m2, h-0.33333333f);
}

PRMAN_INLINE void
RixRgbToHsl(RtColorRGB const &rgb, RtColorRGB &hsl)
{
	RtFloat maxi, mini, maxmin;
	RtFloat rc, gc, bc, hue, sat, light;

	if (rgb.r < rgb.g) {
	    mini = (rgb.r < rgb.b) ? rgb.r : rgb.b;
	    maxi = (rgb.g > rgb.b) ? rgb.g : rgb.b;
	} else {
	    mini = (rgb.g < rgb.b) ? rgb.g : rgb.b;
	    maxi = (rgb.r > rgb.b) ? rgb.r : rgb.b;
	}
	light = (maxi + mini) / 2.0f;

	if (maxi == mini)
		hsl.r = hsl.g = 0.0f;
	else {
		if (light < 0.5f)
			sat = (maxi - mini) / (maxi + mini);
		else
			sat = (maxi - mini) / (2.0f - maxi - mini);

		maxmin = 1.0f / (maxi - mini);
		rc = (maxi - rgb.r) * maxmin;
		gc = (maxi - rgb.g) * maxmin;
		bc = (maxi - rgb.b) * maxmin;

		if	(rgb.r == maxi) hue = bc - gc;
		else if (rgb.g == maxi) hue = 2.0f + rc - bc;
		else			 hue = 4.0f + gc - rc;
		hue /= 6.0f;
		if (hue < 0.0f) hue = hue + 1.0f;

		hsl.r = hue;
		hsl.g = sat;
	}
	hsl.b = light;
}

/*
 * RixXyzToRgb(xyz, rgb) converts a color in CIE xyz space into a sRGB triple.
 */

PRMAN_INLINE void
RixXyzToRgb(RtColorRGB const &xyz, RtColorRGB &rgb)
{
	// XYZ to sRGB matrix, D65 white point.
	// source : http://www.brucelindbloom.com
	//
	//	 3.2404542 -1.5371385 -0.4985314
	//	-0.9692660  1.8760108  0.0415560
 	//	 0.0556434 -0.2040259  1.0572252

	rgb.r =  3.2404542f*xyz.r - 1.5371385f*xyz.g - 0.4985314f*xyz.b;
    rgb.g = -0.9692660f*xyz.r + 1.8760108f*xyz.g + 0.0415560f*xyz.b;
    rgb.b =  0.0556434f*xyz.r - 0.2040259f*xyz.g + 1.0572252f*xyz.b;
}

PRMAN_INLINE void
RixRgbToXyz(RtColorRGB const &rgb, RtColorRGB &xyz)
{
	// sRGB tot XYZ matrix, D65 white point.
	// source : http://www.brucelindbloom.com
	//
	//	 0.4124564  0.3575761  0.1804375
	//	 0.2126729  0.7151522  0.0721750
 	//	 0.0193339  0.1191920  0.9503041

	xyz.r = 0.4124564f*rgb.r + 0.3575761f*rgb.g + 0.1804375f*rgb.b;
 	xyz.g = 0.2126729f*rgb.r + 0.7151522f*rgb.g + 0.0721750f*rgb.b;
 	xyz.b = 0.0193339f*rgb.r + 0.1191920f*rgb.g + 0.9503041f*rgb.b;
}

#endif // RixColorUtils_h
