#ifndef RixBxdf_h
#define RixBxdf_h
/* $Revision: #2 $ $Date: 2014/12/10 $
# ------------------------------------------------------------------------------
#
# Copyright (c) 2013 Pixar Animation Studios. All rights reserved.
#
# The information in this file (the "Software") is provided for the
# exclusive use of the software licensees of Pixar.  Licensees have
# the right to incorporate the Software into other products for use
# by other authorized software licensees of Pixar, without fee.
# Except as expressly permitted herein, the Software may not be
# disclosed to third parties, copied or duplicated in any form, in
# whole or in part, without the prior written permission of
# Pixar Animation Studios.
#
# The copyright notices in the Software and this entire statement,
# including the above license grant, this restriction and the
# following disclaimer, must be included in all copies of the
# Software, in whole or in part, and all permitted derivative works of
# the Software, unless such copies or derivative works are solely
# in the form of machine-executable object code generated by a
# source language processor.
#
# PIXAR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
# ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT
# SHALL PIXAR BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES
# OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
# WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
# ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
# SOFTWARE.
#
# Pixar
# 1200 Park Ave
# Emeryville CA 94608
#
# ------------------------------------------------------------------------------
*/
#include "RixShading.h"
#include "RixShadingUtils.h"
#include "RixBxdfLobe.h"
#include "RixRNG.h"

/**
   The RixBxdf interface is a shading plugin responsible for creating
   a RixBxdf from the the ShadingContext and the set of connected
   patterns.

   The RixBxdf interface characterizes the light-scattering behavior
   at positions in a material.

   Integrators 'drive' Bxdf subclasses by:

    - invoking RixBxdfFactory::Begin to obtain a RixBxdf parameterized by
      the Bxdf's potentially varying input parameters.  BxdfFactory is
      expected to invoke EvalParam for those parameters that pertain to
      the integration request.

    - requesting the Bxdf to generate samples of the bxdf function
      to facilitate integrating a subset of the general light transport
      solution.

    - requesting the Bxdf to evaluate samples associated with a
      particular phase of integration.

    To support several integrator-optimization strategies (diverse sampling
    frequencies, baking, etc.), we characterize a Bxdf as a collection of
    individually sampled lobes.  Integrators may request samples from
    a subset of lobes and obtain insight into the general characteristics
    of each component.

    Execution model:
        - there is one instance of a RixBxdfFactory per bound RiBxdf (RIB)
          request.
        - a single RixBxdfFactory may be active in multiple threads
          simultaneously
        - the context for a per-thread execution is signaled via Begin/End.
          The RixBxdfFactory should stash state in the RixBxdf object and
          consider that the lifetime of a RixBxdf instance is under control
          of the integrator.  Generally integrators should attempt to minimize
          the number of live RixBxdf objects but may nonetheless require a
          large number. For this reason, the RixBxdf instances should
          attempt to minimize memory consumption and construct/deconstruct
          costs.
        - the primary RixBxdf entrypoints operate on a collection of
          shading points in order to reasonably maximize shading coherency
          and support SIMD computation.  Integrators rely on the RixBxdf's
          ability to generate and evaluate a simple across the entire
          collection of points.  Should an integrator require multiple
          samples at the shading points, it will invoke the single-sample
          methods multiple times, taking care to initialize the random
          number contexts appropriately.  Sample evaluation may be performed
          in a 1 sample all points variant - EvaluateSample, and a 1 point
          n samples variant via EvaluateSamplesAtIndex).
          Generation however is constrained to 1 sample n points.
          Evaluation typically has different requirements (eg. for making
          connections in a bidirectional integrator), whereas generation
          typically benefits from being performed all points at once.
**/

// RixBXEvaluateDomain tells Integrator the domain over which
// lighting/connecting/merging needs to be done.
enum RixBXEvaluateDomain
{
    k_RixBXEmptyDomain = 0, // black hole (possibly emissive)
    k_RixBXFront = 1,   // two-sided, non-translucent 
    k_RixBXBack = 2,    // translucent, interior integrator
    k_RixBXBoth = 3,    // thin-translucent, two-sided 
    k_RixBXOutside = 4, // 1-sided, requires Nn/Ngn facing "outside"
    k_RixBXInside = 5,  // 1-sided, requires Nn/Ngn facing "outside"
    k_RixBXVolume = 6   // transmits light from all directions
};

// RixBXTransportTrait tells Bxdf the subset of light transport to consider.
enum RixBXTransportTrait
{
    k_RixBXDirectLighting = 1<<0, // (direct lighting samples only)
    k_RixBXIndirectLighting = 1<<1, // (indirect lighting samples only)
    k_RixBXAnyLighting = k_RixBXDirectLighting | k_RixBXIndirectLighting
};

class RixBsdf;
class RixOpacity;
class RixVolumeIntegrator;
class RixIntegratorContext;
struct RtRayGeometry;

class RixBxdfFactory : public RixShadingPlugin
{
public:
    virtual int GetInterface() const { return k_RixBxdfFactory; }

    // Per-plugin-instance scope is enclosed in Init/Finalize block. Plugin
    // can report errors during init and return non-zero status.
    virtual int Init(RixContext &ctx, char const *pluginPath) = 0;
    virtual RixSCParamInfo const *GetParamTable() = 0;
    virtual void Finalize(RixContext &ctx) = 0;

    // Most Bxdf's don't manipulate opacity or support interior shading.
    // We'd like those to be trivially skippable. Bxdf's with behavior
    // that depends upon instance parameters can "bake" this awareness
    // into their instance data and implement an override for the
    // GetRequirements method.  Values are in the form of a bitfield
    // for compact representation and evaluation.
    enum InstanceHints
    {
        k_TriviallyOpaque=0,
        k_ComputesOpacity=1,    // returns RixOpacity for opacity
        k_OpacityCanBeCached=2, // do not set unless k_ComputesOpacity is set
        k_ComputesPresence=4,   // returns RixOpacity for presence
        k_PresenceCanBeCached=8,// do not set unless k_ComputesPresence is set
        k_OpacityMask=0x0F,
        k_ComputesInterior=0x10,    // has interior integration requirements.
        k_InteriorTransmission=0x20, // supports transmission
        k_InteriorHeterogeneous=0x40, // requires volume, not surface, primvars
        k_InteriorMask=0x70
    };
    virtual int GetInstanceHints(RtConstPointer instancedata) const
    {
        return k_TriviallyOpaque;
    }

    // BeginScatter is expected to return a RixBsdf for the current
    // ShadingContext. The shading mode allows the factory to
    // construct different Bsdfs for different scattering regimes
    // (currently: surface vs volume interior). In constructing a
    // bsdf, the factory plugin typically "samples" its bsdf input
    // parameters via EvalParam method calls on the ShadingContext.  A
    // single factory plugin can have several RixBsdf 'sessions'
    // opened simultaneously and in different threads.  Caller of
    // BeginScatter is expected to call RixBsdf's Release method
    // which, in turn, should call RixBxdfFactory::EndScatter.
    // RixBxdfFactory's subclasses should use 'placement new' atop
    // RixShadingContext::Allocated memory for best performance.
    virtual RixBsdf *BeginScatter(RixShadingContext const *,
                                  RixBXLobeTraits const &hints,
                                  RixSCShadingMode,
                                  RtConstPointer instancedata) = 0;
    virtual void EndScatter(class RixBsdf *bsdf) = 0; 
                    // usually called by RixBsdf::Release

    // BeginOpacity creates a RixOpacity for the current shading context.
    // A non-NULL result indicates that for the specified OpacityRequest
    // the Bxdf desires to express non-trivial opacity behavior.
    // The default implementation implies that the material is fully
    // opaque for surface opacity queries.  Note that BeginInterior
    // takes higher precedence over BeginOpacity for transmission
    // rays. For more details on opacity, refer to RixOpacity class 
    // comments.
    virtual RixOpacity *BeginOpacity(RixShadingContext const *, 
                                     RixSCShadingMode,
                                     RtConstPointer instancedata)
                    { return 0; }
    virtual void EndOpacity(class RixOpacity *) {}

    // BeginInterior creates a RixVolumeIntegrator for the current shading
    // context.  A non-zero result indicates that for the specified 
    // shading mode, the Bxdf desires to express non-trivial volume 
    // behavior for the presumed volume interior region associated 
    // with the bound surface. The default implementation supports
    // the common case where a material has no special volume integrator.
    virtual class RixVolumeIntegrator *BeginInterior(RixShadingContext const *, 
                                                    RixSCShadingMode,
                                                    RtConstPointer instancedata)
                    { return 0; }
    virtual void EndInterior(RixVolumeIntegrator *) {}
                                        
protected:
    RixBxdfFactory() : RixShadingPlugin(k_RixShadingVersion) {}
    virtual ~RixBxdfFactory() {}
};

// RixBsdf holds all state computed by BeginScatter, including
// the RixShadingContext.
class RixBsdf
{
public:
    RixBsdf(RixShadingContext const *sCtx, RixBxdfFactory *fact) :
        shadingCtx(sCtx), bxdfFactory(fact) {}

    virtual ~RixBsdf() {}

    RixShadingContext const *GetShadingCtx() { return shadingCtx; }
    RixBxdfFactory *GetBxdfFactory() { return bxdfFactory; }

    // The domain over which this Bsdf evaluates samples. Note
    // that it may Generate discrete samples in any direction, this only
    // tells where incoming samples could Evaluate to non-zero.
    virtual RixBXEvaluateDomain GetEvaluateDomain() = 0;

    // The types of samples this BxdfEvaluator can generate.
    virtual void GetAggregateLobeTraits(RixBXLobeTraits *t) = 0;

    PRMAN_INLINE RixBXLobeTraits GetAllLobeTraits()
    {
        RixBXLobeTraits t;
        this->GetAggregateLobeTraits(&t);
        return t;
    }

    // Bxdfs can be queried for general material properties to facilitate
    // integration tasks.  Bxdfs should return k_RixSCInvalidDetail if
    // a particular property is unsupported.  If a property is supported
    // Bxdf should return k_RixSCUniform or k_RixSCVarying according to
    // the detail of the result.
    enum BxdfProperty
    {
        k_Albedo,       // RtColorRGB
        k_MaterialIor   // RtFloat
    };
    virtual RixSCDetail GetProperty(BxdfProperty, void const **result)
    {
        // Note: currently we offer a default implementation.
        // We may choose to enforce implementing this in the future
        // so we encourage you to implement this method.
        return k_RixSCInvalidDetail;
    }

    // EmitLocal: used for baked, pre-integrated, indirect results
    virtual bool EmitLocal(RtColorRGB* result)
    {
        // Note: The default is no local emission, and returning false here
        //       indicates to the integrator that 'result' is untouched and
        //       that the integrator should not do anything with the results
        //       array.
        return false;

        /*
          // For bxdfs that do have local emission, they should return true
          // and write shadingCtx->numPts colors to the 'result' array.
          // The integrator will then include the returned colors in the
          // direct lighting for the geometry. For example:

          RtInt nPts = shadingCtx->numPts;
          for (int i = 0; i < nPts; i++)
              result[i] = RtColorRGB(1.0f);

          return true;
        */
    }

    // GenerateSample:
    //  Bxdf is expected to generate a sample direction and lobe weights
    //  for each point in the ShadingContext (shadingCtx). Bxdfs must
    //  respect the transportTrait and lobesWanted request and indicate 
    //  which class of lobe is associated with each sample by setting 
    //  lobesSampled for each generated sample. If and only if the bxdf 
    //  is unable to  generate a requested sample, then lobesSampled should 
    //  be set to  k_RixBXNullTrait; for example, if the lobesWanted argument 
    //  requests  a specific lobe (e.g., diffuse reflection) that the Bxdf 
    //  does not  support (for instance, that Bxdf only supports glossy 
    //  reflections), then lobesSampled should be set to k_RixBXNullTrait. 
    //  However, if it is possible to generate the requested samples, then 
    //  lobesSampled should not be set to k_RixBXNullTrait (and should instead 
    //  be set to the sampled lobe for each point in the ShadingContext). Note 
    //  that it is possible for the returned lobe weights to be set to zero 
    //  for one or more of the points in the ShadingContext when there is no 
    //  surface response for the sampled directions, although usually the 
    //  returned pdfs will be non-zero. The pdf should be set to zero only 
    //  if the probability of the Bxdf model generating a given sample is 
    //  zero (see the documentation for EvaluateSample() for an example 
    //  where setting the pdf to zero is appropriate).
    virtual void GenerateSample(RixBXTransportTrait transportTrait,
                                RixBXLobeTraits const *lobesWanted,
                                RixRNG *rng,
                                RixBXLobeSampled *lobesSampled,
                                RtVector3 *sampleDirs,
                                RixBXLobeWeights &weights,
                                RtFloat *forwardPdfs, RtFloat *reversePdfs) = 0;

    // EvaluateSample:
    //  Bxdf is expected to evaluate itself subject to the lobesWanted
    //  request.   In addition to sampleDirs, the ShadingContext variables
    //  (primarily Vn, Nn, Tn) must be consulted.  The lobesEvaluated output
    //  can be set to indicate invalid conditions. If and only if the bxdf 
    //  is unable to satisfy the request, then lobesEvaluated should be set
    //  to k_RixBXNullTrait. For example, if the lobesWanted argument 
    //  requests a specific lobe (e.g., diffuse reflection) that the Bxdf 
    //  does not support (for instance, that Bxdf only supports glossy 
    //  reflections), then lobesEvaluated should be set to k_RixBXNullTrait. 
    //  However, if it is possible to evaluate the request, then 
    //  lobesEvaluated should not be set to k_RixNullTrait (and should 
    //  instead be set to the evaluated lobe for each point in the 
    //  ShadingContext). For valid samples, usually the pdf will be non-zero
    //  but the weight may be set to 0 if there is no surface response for 
    //  the given directions. In some cases, it is appropriate to set the pdf
    //  to zero when a given sample could never have been generated (for 
    //  example, if the sample direction is below the horizon of the surface 
    //  for a purely reflective surface).
    virtual void EvaluateSample(RixBXTransportTrait transportTrait,
                                RixBXLobeTraits const *lobesWanted,
                                RixBXLobeTraits *lobesEvaluated,
                                RtVector3 const *sampleDirs,
                                RixBXLobeWeights &weights,
                                RtFloat *forwardPdfs, RtFloat *reversePdfs) = 0;

    // EvaluateSamplesAtIndex
    // do multiple evals at a single shading point. Also see the documentation
    // above for EvaluateSample().
    virtual void EvaluateSamplesAtIndex(RixBXTransportTrait transportTrait,
                                RixBXLobeTraits const &lobesWanted,
                                RtInt index,
                                RtInt numSamples,
                                RixBXLobeTraits *lobesEvaluated,
                                RtVector3 const *sampleDirs,
                                RixBXLobeWeights &weights,
                                RtFloat *forwardPdfs, RtFloat *reversePdfs) = 0;

    // Release does any cleanup that might be needed (often none and the
    // base implementation is fine) and then calls the base implementation.
    // A RixBxdf that contains another RixBxdf would need to call Release
    // on its child as part of its own Release.
    virtual void Release() { if (bxdfFactory) bxdfFactory->EndScatter(this); }

protected:
    RixShadingContext const *shadingCtx;
    RixBxdfFactory *bxdfFactory;
};

// RixOpacity objects are obtained from the BxdfFactory::BeginOpacity 
// when it determines conditions warrant non-trivial responses to
// either or both of Presence and Opacity queries.  GetPresence
// is invoked when an object isn't trivially 'present' and may
// be used for radiance queries to infer "ray continuation". It is
// useful to express cutouts as, for example, a leaf shape modeled
// with a texture map. Most objects are trivially present and the 
// BxdfFactory should respond to NULL RixOpacity when the
// RixSCShadingMode is k_RixSCPresenceQuery.  In the case of
// an opaque leaf, BxdfFactory should instantiate a RixOpacity
// subclass to respond to GetPresence requests and the 
// "presence closure" should be constructed with the minimum 
// state required to respond to this request.  If our example
// leaf is opaque for shadowing, the BxdfFactory should respond
// to BeginOpacity requests with NULL for k_RixSCTransmissionQuery.
// But if the shadow of the leaf wants leaf coloration, BxdfFactory
// should produce a RixOpacity subclass that combines the effects
// of presence and coloration into a single opacity value.  Since
// opacity can be colored, keep in mind that it is the inverse of
// transparency and user interfaces usually  prefer to present
// a transparency color to the user.
// 
class RixOpacity
{
public:
    RixOpacity(RixShadingContext const *sCtx, RixBxdfFactory *fact) :
        shadingCtx(sCtx), bxdfFactory(fact) {}
    virtual ~RixOpacity() {}
    RixBxdfFactory *GetBxdfFactory() { return bxdfFactory; }
    RixShadingContext const *GetShadingCtx() { return shadingCtx; }

    // GetPresence: fill shadingCtx->nPts worth of RtFloat presence
    // values...  1 is present, 0 is absent, between is fractional 
    // presence and is useful for antialiasing. A return code of
    // false signals that the object is trivially presence over
    // the shading context, true signals that results should be 
    // considered. NB: a false return might suggest that no
    // RixOpacity object should have been constructed in the 
    // first place.
    virtual bool GetPresence(RtFloat *result) = 0;

    // GetOpacity: fill shadingCtx->nPts worth of RtColor opacity
    // values. Opacity values are used for transmission rays (aka 
    // shadows) and should be modulated by presence. NB: other
    // aspects of opacity (ie thin-glass, thick glass) are the 
    // responsibility of the Bsdf and are conveyed via transmitted 
    // samples to the integrator.
    virtual bool GetOpacity(RtColorRGB *result) = 0;

    virtual void Release() { if (bxdfFactory) bxdfFactory->EndOpacity(this); }

protected:
    RixShadingContext const *shadingCtx;
    RixBxdfFactory *bxdfFactory;
};

// RixVolumeIntegrators can be obtained from the BxdfFactory at 
// the hit point where a ray enters an interior region.
// A VolumeIntegrator can be seen as a delegate for the real
// IntegratorCtx that implements special behavior behind the
// GetNearestHits and GetTransmission methods.  The idea is 
// that the integration complexity in a volume region can be 
// hidden from the outside world by reducing more complex 
// light-paths into a single measurement of energy throughput, 
// transmission, coupled with potentially distinct shading 
// contexts to capture light transfer into the volume region. 
// VolumeIntegrators can either be built-in or compiled-in to 
// a bxdf.  In the former case, a reference to an instance of 
// a VolumeIntegrator should be obtained from the RixShadingContext. 
// To support pre-constructed builtin VolumeIntegrators we offer
// a generic method to pass instance parameters to the integrator.
// Typically builtin VolumeIntegrators define a struct comprised of 
// the parameters it requires from the enclosing bxdf factory.
// The memory for (and evaluation of) the parameters is the responsibility
// of the enclosing bxdf. This extra dance is required to diminish 
// the likelihood of disruption caused by the addition of new parameters 
// by plugin/builtin volume integrators. In the direct-linked case
// clients can bypass the SetParameters convenience routines in
// favor of direct constructor.
class RixVolumeIntegrator
{
public:
    RixVolumeIntegrator(RixShadingContext const *sCtx, RixBxdfFactory *f) :
        shadingCtx(sCtx), bxdfFactory(f), params(NULL) {}
    virtual ~RixVolumeIntegrator() {}
    RixShadingContext const *GetShadingCtx() { return shadingCtx; }
    RixBxdfFactory *GetBxdfFactory() { return bxdfFactory; }

    virtual void SetParameters(void const *subclassParams) 
    {
        params = subclassParams;
    }

    class IntegratorDelegate
    {
    public:
        virtual void PerformDirectLighting(RixShadingContext const &,
                                       RixBXLobeTraits const *lobesWanted,
                                       int step) = 0;

    protected:
        virtual ~IntegratorDelegate() {}
    };

    virtual void Release() { if(bxdfFactory) bxdfFactory->EndInterior(this); }

    virtual void GetNearestHits(RtInt numRays, RtRayGeometry const *rays, 
                                RixRNG *rng,
                                RixBXLobeTraits const &lobesWanted, 
                                RixIntegratorContext &iCtx,
                                // results: (per-ray transmission deposited
                                //  on resulting ShadingContexts' 
                                //  transmission field). Inscattered
                                //  radiance can be splatted directly to
                                //  the screen.
                                IntegratorDelegate *lcb,
                                RtInt *numGrps, 
                                RixShadingContext const **shadeGrps,
                                // optional input:
                                char const *subset=NULL
                                )=0;

    // We provide a default implementation of GetTransmission because
    // some volume integrators may be opaque to transmission rays.
    // This occurs when the only supported light transport mode is indirect.
    // In this case, the volume integrator's associated bxdffactory may
    // select to return a NULL volume integrator for transmission queries.
    virtual void GetTransmission(RtInt numRays, RtRayGeometry const *rays,
                                 RixRNG *rng,        
                                 RtColorRGB *trans, 
                                 // optional input;
                                 char const *subset=NULL) {}

protected:
    RixShadingContext const *shadingCtx;
    RixBxdfFactory *bxdfFactory;
    void const *params;
};

#define RIX_BXDFPLUGINCREATE \
extern "C" PRMANEXPORT RixBxdfFactory *CreateRixBxdfFactory(const char *hint)

#define RIX_BXDFPLUGINDESTROY \
extern "C" PRMANEXPORT void DestroyRixBxdfFactory(RixBxdfFactory *bxdf)

#endif
