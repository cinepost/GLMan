#ifndef RixDeepTexture_H
#define RixDeepTexture_H
/* $Revision: #3 $ $Date: 2014/12/10 $
# ------------------------------------------------------------------------------
#
# Copyright (c) 2010 Pixar Animation Studios. All rights reserved.
#
# The information in this file (the "Software") is provided for the
# exclusive use of the software licensees of Pixar.  Licensees have
# the right to incorporate the Software into other products for use
# by other authorized software licensees of Pixar, without fee.
# Except as expressly permitted herein, the Software may not be
# disclosed to third parties, copied or duplicated in any form, in
# whole or in part, without the prior written permission of
# Pixar Animation Studios.
#
# The copyright notices in the Software and this entire statement,
# including the above license grant, this restriction and the
# following disclaimer, must be included in all copies of the
# Software, in whole or in part, and all permitted derivative works of
# the Software, unless such copies or derivative works are solely
# in the form of machine-executable object code generated by a
# source language processor.
#
# PIXAR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
# ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT
# SHALL PIXAR BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES
# OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
# WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
# ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
# SOFTWARE.
#
# Pixar
# 1200 Park Ave
# Emeryville CA 94608
#
# ------------------------------------------------------------------------------
*/
#include "RixInterfaces.h"

/**
  RixDeepTexture
 
   This interface provides the classes and methods necessary to create,
   load, and modify Pixar deep texture files.  It maintains a tile cache,
   under the covers, making it possible to work on files without loading
   them entirely into memory.
 
   The API supports an arbitrary number of images in a single file, each
   with its own resolution, tile size, and view matrices.
 
   The library can read and write old deep shadow files in addition to
   newer, more general deep texture files.  Deep shadow files are
   limited to a single sub-image, but otherwise have the same API as the
   newer interface.
 */
class RixDeepTexture : public RixInterface
{
protected:
    /// Constructor is for internal use only.
    RixDeepTexture() : RixInterface(2) {}

public:
    enum Compression
    {
        k_CmpNone = 0,
        k_CmpRLE = 2,
        k_CmpLZW = 3,
        k_CmpHUFFMAN = 5,
        k_CmpZIP = 6
    };
    
    enum DataType
    {
        k_TypeBYTE = 1,
        k_TypeSHORT = 2,
        k_TypeWORD = 3,
        k_TypeFLOAT = 4,
        k_TypeHALF = 5
    };
    
    enum ErrorCodes
    {
        k_ErrNOMETADATA = -14,       ///< Metadata entry was not found
        k_ErrBADCHANNEL = -13,       ///< Channel mismatch between pixels
                                     ///   or tiles
        k_ErrREADONLY = -12,         ///< Attempt to modify file loaded as
                                     ///   read only
        k_ErrCAPACITY = -11,         ///< Tried to go past 2GB on a small
                                     ///   capacity file
        k_ErrTILECOMPRESSION  = -10, ///< Error during tile compression
        k_ErrUNFINISHED = -9,        ///< Illegal operation on pixel with
                                     ///   unresolved compression state
        k_ErrRANGE = -8,             ///< Out of range parameter
        k_ErrNOMEM = -7,             ///< Ran out of memory
        k_ErrEMPTY = -6,             ///< Illegal operation on an
                                     ///   empty structure
        k_ErrNOIMAGE = -5,           ///< The specified image was not found
        k_ErrUNSUPPORTED = -4,       ///< The specified operation is
                                     ///   not supported.
        k_ErrBADFILE = -3,           ///< File was corrupt
        k_ErrNOFILE = -2,            ///< File was not found or was invalid
        k_ErrERR = -1,               ///< File was not found or was invalid
        k_ErrNOERR = 0               ///< No worries
    };
    
    // forward declaration of our types...
    class DeepCache;
    class DeepFile;
    class DeepImage;
    class DeepMetadata;
    class DeepPixel;
    
    /// Create a new tile cache.  This cache can be associated with one
    /// more more images and enables out-of-core DeepFile manipulation.
    virtual DeepCache *CreateCache(int numTiles)=0;

    /// Destroy a cache.  This must not be called until all open files
    /// associated with the cache have been destroyed.
    virtual int DestroyCache(DeepCache *)=0;
    
    /// Open a deep texture file with the given filename, managed by the
    /// given cache. 
    virtual int CreateFile(const char *name, DeepCache *, DeepFile **result)=0;

    /// Open and file and check whether it appears to be a deep texture.
    /// Returns k_ErrNOERR and sets version to the file format version if
    /// the named file is a deep texture.
    virtual int IsDeepFile(const char *name, DeepCache *, int *version)=0;

    /// Open a deep texture file with the given filename, managed by the
    /// given cache.
    virtual int OpenFile(const char *name, const char *mode, DeepCache *, 
                        DeepFile **result)=0;

    /// Destroy a DeepFile produced by either OpenFile or CreateFile
    virtual int DestroyFile(DeepFile *)=0;

    /// Create a DeepPixel for use with DeepImage channel data.
    virtual DeepPixel *CreatePixel(int numChan)=0;

    /// Destroy a DeepPixel.
    virtual void DestroyPixel(DeepPixel *)=0;

    class DeepCache
    {
    public:
        virtual int Sync()=0;

    protected:
        /// Internal only. Use RixDeepTexture::DestroyCache
        virtual ~DeepCache() {} 
    };

    ///
    /// DeepFile
    ///
    /// This object allows the manipulation of the DeepImage
    /// contents of a deep texture file. A DeepFile can
    /// contain multiple DeepImage objects.
    class DeepFile
    {
    protected:
        /// Internal only. Use RixDeepTexture::DestroyFile
        virtual ~DeepFile() {} 

    public:

        /// Return the format version of the given file.
        virtual int FileVersion()=0;

        /// Get a handle to the image-specific metadata.
        /// May be null on older files.
        virtual DeepMetadata *GetMetadata()=0;

        /// Return the number of images in this file.
        virtual int CountImages()=0;
        
        /// Add an image to this file.
        virtual int AddImage(const char *nm, int numChan,
                     int w, int h, 
                     int tw, int th,
                     float *NP,
                     float *Nl,
                     Compression,
                     DataType,
                     DeepImage **result)=0;

        /// Add an image to this file.  Additionally takes a formattype and
        /// formatversion to automatically add to the metadata.
        virtual int AddImage(const char *nm, int numChan,
                     int w, int h, 
                     int tw, int th,
                     float *NP,
                     float *Nl,
                     Compression,
                     DataType,
                     const char *formatType,
                     int formatVersion,
                     DeepImage **result)=0;


        /// If the this contains an image with the given name, return a
        /// pointer to it. Returns k_ErrNOIMAGE if the named image doesn't 
        /// exist.  The resulting pointer is guaranteed to be valid until 
        /// Close() is called on this file.
        virtual int GetImageByName(const char *, DeepImage **result)=0;
                     
        /// Return the nth image from this file.  Returns k_ErrNOFILE
        /// if the file doesn't exist, or k_ErrNOIMAGE if the indexed image 
        /// doesn't exist.  The resulting pointer is guaranteed to be valid 
        /// until Close() is called on this file.        
        virtual int GetImageByIndex(int, DeepImage **result)=0;
        
        /// Close this file, writing out all modified tiles.
        virtual int Close()=0;
        
        /// Write out all modified tiles of this file causing
        /// the file on disk to reflect any changes that have been made.
        virtual int Sync()=0;
    };

    ///
    /// DeepImage
    ///
    /// This object allows the manipulation of the DeepPixel
    /// data contained within this image object.
    ///
    class DeepImage
    {
    protected:
        /// Internal only.
        virtual ~DeepImage() {}

    public:
        /// return the name of this image.  The resulting pointer is
        /// guaranteed to be valid until DtexClose() is called on the 
        /// containing file.
        virtual const char *GetName()=0;
        /// return the number of channels in this image
        virtual int GetNumChan()=0;
        /// return the width of this image in pixels
        virtual int GetWidth()=0;
        /// return the height of this image in pixels
        virtual int GetHeight()=0;
        /// return the width of the tiles in this image, in pixels
        virtual int GetTileWidth()=0;
        /// return the height of the tiles in this image, in pixels
        virtual int GetTileHeight()=0;
        /// copy the projection matrix from this image to NP.
        virtual int GetNP(float *NP)=0;
        /// copy the light-space matrix from this image to Nl.
        virtual int GetNl(float *Nl)=0;
        /// return the compression type of this image.
        virtual Compression GetCompression()=0;
        /// return the data type of this image.
        virtual DataType GetDataType()=0;
        /// Get a handle to the image-specific metadata.
        /// May be null on older files.
        virtual DeepMetadata *GetMetadata()=0;


        /// Copy the given pixel data into pixel x, y of the specified image. 
        /// numPoints indicates how many points there are.  data should
        /// point to numPoints*(GetNumChan()+1) floats.
        virtual int SetPixelData(int x, int y, int numPoints, 
                                 float *data)=0;

         /// Copy the given pixel into pixel x,y of the specified image.  
         /// pix must have either the same number of channels as img, or 
         /// one channel. If pix has any unresolved compression state, 
         /// k_ErrERR is returned. Take care to call pix->FinishPixel before 
         /// you use SetPixel.
        virtual int SetPixel(int x, int y, DeepPixel *pix)=0; 

        /// Copy the pixel at position x,y into the given DeepPixel.
        /// The DeepPixel is resized if necessary, and if the number 
        /// of channels in pix is different than the number of
        /// channels in this image, pix is modified to match.
        /// Returns k_ErrNOERR if no error, k_ErrRANGE if the requested pixel
        /// outside the image, or k_ErrBADFILE if the file is found to be
        /// corrupt.
        virtual int GetPixel(int x, int y, DeepPixel *pix)=0;

        /// Look up the pixel's interpolated value at depth z, and put
        /// the result in data. Data must point at float storage large
        /// enough to encompass the number of channels in the image.
        virtual int Eval(int x, int y, float z, float *data)=0;

        /// Computes the range over which the specified pixel is defined.
        /// If the pixel is non-empty, the range is returned in min and max
        /// and the function returns k_ErrNOERR.  If the pixel is empty, 
        /// k_ErrEMPTY is returned and min and max are undefined.
        virtual int GetZRange(int x, int y, float *min, float *max)=0;

        /// Computes the mean depth found in the pixel and the overall
        /// coverage.  This is useful for displaying deep images.
        virtual int GetMeanDepth(int x, int y, float *mean, float *alpha)=0;
    };

    ///
    /// DeepMetadata
    ///
    /// This object contains a list of key/value pairs that can be associated
    /// with a file or image and will be persisted on disk.
    ///
    /// The token is a string specifying the type and name of the field and
    /// is given in the standard RenderMan style, e.g., ``float bbox[6]``.
    /// Supported types are: float, int, point, color, vector, normal,
    /// hpoint, matrix, and string.
    ///
    /// The associated data to write is given by the value pointer.
    /// In the case of string data, this should point to ``char *``
    /// pointers that point to the strings themselves (i.e., argv style).
    ///
    class DeepMetadata
    {
    protected:
        /// Internal only.
        virtual ~DeepMetadata() {}

    public:

        /// Add or update a metadata field. If the value is null, the metadata
        /// field will be removed.
        virtual int Set(char const *token, void const *value)=0;

        /// Return how many metadata fields this list has.
        virtual int Count()=0;

        /// Metadata fields are indexed in no particular order; this function
        /// is simply a convenience for enumerating all attached metadata.
        /// Returns k_ErrNOMETADATA if the given field doesn't exists.
        /// The resulting pointers are valid until either the file is closed
        /// or Set() modifies this field.  Data behind these pointers must
        /// not be changed.
        virtual int GetByIndex(int index,
                               char const **token, void const **value)=0;

        /// Metadata fields may also be retrieved by an unadorned name.
        virtual int GetByName(char const *name,
                              char const **token, void const **value)=0;
    };

    ///
    /// DeepPixel
    ///
    /// Because deep texture pixels are varying in size, a pixel's storage
    /// must be dynamically allocated.  Th DeepPixel allows users to build 
    /// and evaluate pixels.  The structure is fairly heavyweight because 
    /// it stores auxiliary information related to compression.  We don't 
    /// recommend allocating an entire image of these structures yourself; 
    /// keep * a small number of DeepPixels around, and use img->SetPixel 
    /// to modify a DeepImage.
    ///
    /// The following functions let you create, modify, and
    /// destroy DeepPixels.  Pixels may be cleared with Clear().
    /// New datapoints may be added (in increasing Z order) with
    /// Append().  If compression is used, a pixel must be Finish()'ed 
    /// before lookups can be performed in the pixel.
    ///
    class DeepPixel
    {
    protected:
        /// Internal only.  Use RixDeepTexture::DestroyPixel
        virtual ~DeepPixel() {}

    public:
        virtual int Clear(int numChan)=0;
        virtual int Empty()=0;

        /// Initialize this DeepPixel to the uncompressed values provided.
        virtual int SpecifyPixel(int numChan, int numPoints, float *data)=0;

        /// Return 1 if this pixel has duplicates for all its values.
        /// Return 0 otherwise.  If this pixel has no control points, return 1.
        virtual int IsMonochrome()=0;

        /// Return the number of channels in this pixel
        virtual int GetNumChan()=0;

        /// Return the number of control points in this pixel.
        /// Returns zero if there are no control points, k_ErrERROR if the 
        /// pixel has unresolved compression state.
        virtual int GetNumPoints()=0;

        /// Get the i'th control point in the given pixel.  If the indicated
        /// control point is accessible, z and data are set and k_ErrNOERR
        /// is return.  If the pixel does not exist, k_ErrNOPOINT is returned
        /// and *z and *data are undefined.  If the pixel has unresolved
        /// compression state, k_ErrUNFINISHED is returned and *z and *data
        /// are undefined.
        virtual int GetPoint(int i, float *z, float *data)=0;

        /// Modify the i'th control point in this pixel.  If the indicated
        /// control point is accessible and if the supplied z is legal, the
        /// pixel is modified and kErrNOERR is returned.  If the point does
        /// not exist, k_ErrNOPOINT is returned.  If the pixel has unresolved
        /// compression state, k_ErrUNFINISHED is returned.
        virtual int SetPoint(int i, float z, float *data)=0;

        /// Copy the source pixel state into ours. Ensure that our
        /// channel and compression state match that of src.
        virtual int Copy(DeepPixel *src)=0;
        
        /// Merge a source pixel's state into ours. The result is that
        /// our pixel will contain all control points in both
        /// pixels. The channel count in the source pixel must match
        /// our own, and both pixels must not have any incomplete
        /// compression state.
        virtual int Merge(DeepPixel *src) = 0;

        /// Merge a source pixel's state into ours, additionally taking
        /// into account volume segments in either input.  Regions of
        /// volume are flagged with a negative alpha and extend to the next
        /// sample in the pixel.  There must be at least one non-volume
        /// sample marking the end of chain (which may be completely
        /// transparent).
        ///
        /// This assumes a four channel RGBA pixel function when splitting
        /// and merging volume regions. The rgbChannel must be the index of
        /// the first color channel, with the assumption that all three
        /// color channels are contiguous. The alphaChannel must be the
        /// index of the alpha channel.  Any additional channels will be
        /// copied unchanged from the most recent volume sample.
        virtual int Merge(DeepPixel *src,
                          int rgbChannel, int alphaChannel) = 0;


        /// If this pixel is in "compress mode" (non-zero compression),
        /// this function finished compression and sets compression error
        /// to zero.  This must be called before any lookups on the pixel.
        /// If the pixel alred has a zero compression error, this method
        /// has no effect.
        virtual int Finish()=0;

        /// Add a data point to the end of this pixel.  tolerance
        /// provides an accuracy hint to compressors. The number of
        /// floats provided in data must be equal to the pixel's
        /// channel count.
        virtual int Append(float z, float *data, float tolerance)=0;

        /// Evaluate this pixels texture at depth z and put the result in
        /// data. The amount of float storage in data must be equal to
        /// the pixel's channel count.
        virtual int Eval(float z, float *data)=0;

        /// Composite four channel RGBA within the pixel and store the
        /// result in data. rgbChannel must be the index of the first
        /// color channel, with the assumption that all three color
        /// channels are contiguous. alphaChannel must be the index of
        /// the alpha channel. data must be a buffer of at least four
        /// floats. If the pixel is empty, k_errEMPTY is returned and
        /// data is filled with zeros. Otherwise, data[0], data[1],
        /// and data[2] contain the composited color values and
        /// data[3] contains the composited alpha value, and the
        /// method returns k_errNOERR.
        virtual int Composite(int rgbChannel, int alphaChannel, float *data)=0;

        /// Computes the range over which the specified pixel is defined. If
        /// the pixel is non-empty, the range is returned in zmin and zmax
        /// and the method returns k_ErrNOERR.  If this pixel is empty,
        /// we return k_ErrEMPTY and *zmin and *zmax are undefined.  If
        /// this pixel has undefined compression state, k_ErrUNFINISHED is
        /// returned and *zmin and *zmax are undefined.
        virtual int GetZRange(float *zmin, float *zmax)=0;

        /// Compute the weighted pointwise average of the incoming array
        /// of pixels and weights and place the result into this DeepPixel.
        virtual int Average(int n, DeepPixel *pixels[], float weights[],
                            float tolerance)=0;

        /// Compress a src DeepPixel into this DeepPixel. Currently you
        /// can't compress a DeepPixel into itself (so this != src).
        virtual int Compress(DeepPixel *src, float tolerance)=0;
        
    }; /* end of DeepPixel */
    
}; /* end of RixDeepTexture */

#endif
