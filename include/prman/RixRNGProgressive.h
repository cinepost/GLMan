#ifndef RixRNGProgressive_h
#define RixRNGProgressive_h
// $Revision: #20 $ $Date: 2014/07/14 $
//
// This file is intended solely for inclusion by RixInterfaces.h and should 
// note be included directly.  Here we define inline implementations of private
// RixRNG methods.  Conceptually the contents of this file are "opaque" but
// we provide them to deliver the highest performance.  Each release may
// differ from the last, so in order to obtain the new benefits, clients
// will need to recompile.
//
// These routines collectively implement progressive multi-jittered samples
// (PMJ) based on precomputed tables.  The progressive multi-jittered samples
// are related to the correlated multi-jittered samples described in Pixar 
// Technical Memo #13-01, "Correlated Multi-Jittered Sampling" 
// (http://graphics.pixar.com/library/MultiJitteredSampling/), but are
// progressive -- which is important for interactive/iterative rendering.
//
// Alternatively, you may use the fields in Ctx as inputs to your own 
// sampling sequence instead if you prefer.
//

/*
# ------------------------------------------------------------------------------
#
# Copyright (c) 2013-2014 Pixar Animation Studios. All rights reserved.
#
# The information in this file (the "Software") is provided for the
# exclusive use of the software licensees of Pixar.  Licensees have
# the right to incorporate the Software into other products for use
# by other authorized software licensees of Pixar, without fee.
# Except as expressly permitted herein, the Software may not be
# disclosed to third parties, copied or duplicated in any form, in
# whole or in part, without the prior written permission of
# Pixar Animation Studios.
#
# The copyright notices in the Software and this entire statement,
# including the above license grant, this restriction and the
# following disclaimer, must be included in all copies of the
# Software, in whole or in part, and all permitted derivative works of
# the Software, unless such copies or derivative works are solely
# in the form of machine-executable object code generated by a
# source language processor.
#
# PIXAR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
# ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT
# SHALL PIXAR BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES
# OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
# WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
# ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
# SOFTWARE.
#
# Pixar
# 1200 Park Ave
# Emeryville CA 94608
#
# ------------------------------------------------------------------------------
*/


//
// Progressive multi-jittered samples (PMJ).
// Lookups in a pre-generated tables of progressive samples.
// The order of the samples is carefully swapped: local swapping of the
// order of the samples preserves the sample values and convergence, but 
// swapping their order a little makes them more suitable for "padding"
// into higher-dimensional samples (decorrelating the samples in different
// dimensions).
// We also scramble the bits -- this preserves the PMJ properties
// but further increases the number of apparently different sample sequences.
// x and y could be flipped in order to add further apparent randomness to 
// the samples, thus reducing aliasing from using a limited number of tables
// -- but this alone is not sufficient; bit scrambling gives many more 
// different sequences.
// (In contrast, regular Cranley-Patterson rotation is a very bad idea
// for PMJ samples: it increases variance by a lot.  Probably because the
// strata on edges get wrapped around introducing large jumps for the
// samples in those strata.  If we really needed rotation, we could 
// restrict the rotations to e.g. multiples of 0.25 or 0.125.)
//


#define N_PMJ_TABLES 401
#define PMJ_TABLE_SIZE 1024


class ProgressiveSampler : public Generator {
public:
    void *pmjTables;

    ProgressiveSampler(void *tables) : pmjTables(tables) { }

private:

    // Compute a repeatable random unsigned int based on value and scramble.
    // Same as HashToRandom() but returns unsigned int instead of float.
    PRMAN_INLINE unsigned int HashToRandomUInt(
        unsigned int const value,
        unsigned int const scramble )
    {
        unsigned int result = value;
        result ^= scramble;
        result ^= result >> 17;
        result ^= result >> 10;  result *= 0xb36534e5;
        result ^= result >> 12;
        result ^= result >> 21;  result *= 0x93fc4795;
        result ^= 0xdf6e307f;
        result ^= result >> 17;  result *= 1 | scramble >> 18;
        return result;
    }


    // Scramble bits of sample f with bits of 'scramble' and convert back to
    // float.  Both f and the result are floats between 0.0 and 1.0.
    PRMAN_INLINE RtFloat fpScramble(float f, unsigned int scramble)
    {
        union
        {
            float f;
            unsigned int i;
        } f2i;
        f2i.f = f + 1.0f; // map f to [1,2) so we know the exponent is 0
        f2i.i ^= (scramble >> 9); // scramble the fp mantissa bits
        return f2i.f - 1.0f; // map result to [0,1)
    }


    // Compute a progressive 1D PMJ (actually PJ) sample
    PRMAN_INLINE RtFloat progressive1DSample(
        const unsigned int pattern,
        const unsigned int sample )
    {
        RtFloat result;
        float *randomTable;
        unsigned int t, s;
        const unsigned int nRandomTables = N_PMJ_TABLES; // 401
        const unsigned int tableSize = PMJ_TABLE_SIZE; // 1024
        const unsigned int totalTableSize = nRandomTables * tableSize;

        if (sample > totalTableSize) {
            // Resort to random when running out of table entries after 
            // 401*1024 = 410624 samples with same pattern id
            result = RixRNGUtils::HashToRandom(sample, pattern * 0x51633e2d);
            return result;
        }

        // Scramble the input pattern some more
        unsigned int pattern1 = HashToRandomUInt(pattern, 0x51633e2d);
        unsigned int pattern2 = HashToRandomUInt(pattern, 0x68bc21eb);
        unsigned int pattern3 = HashToRandomUInt(pattern, 0x967a889b);

        // Select which randomTable based on pattern1
        t = pattern1 % nRandomTables;
        assert(t < nRandomTables);

        // Select table entry.  See comments in 2D version.
        s = sample + t * tableSize;
        if (pattern2 & 0x1) s = (sample & 0x1) ? s-1 : s+1;
        if (pattern2 & 0x2) s = (sample & 0x2) ? s-2 : s+2;
        if (pattern2 & 0x4) s = (sample & 0x4) ? s-4 : s+4;
        if (pattern2 & 0x8) s = (sample & 0x8) ? s-8 : s+8;
        s = s % totalTableSize; // to avoid running off end of randomTables

        // Lookup sample in table
        float **tables = (float**)pmjTables;
        randomTable = tables[0]; // 0 = 1D
        result = randomTable[s]; // progressive jittered 1D
        assert(0.0f <= result && result <= 1.0f); // 1.0 is okay here

        // Random (but consistent) flips
        //if (pattern3 & 0x1) result = 1.0f-result;

        // Scramble bits of sample with bits of pattern, convert back to float
        result = fpScramble(result, pattern3);

        // Ensure (bit-scrambled) values are strictly less than 1.0
        if (result > 0.999990f) result = 0.999990f;
        assert(0.0f <= result && result < 1.0f);

        return result;
    }


    // Compute a progressive 2D PMJ sample -- new version with 401 tables.
    // Multiple patterns generated from input pattern with HashToRandom() with
    // some select bit patterns.
    // Selective, local swapping of the order of the samples (preserving the 
    // sample values, just swapping their order a little).
    // Also bit-scrambling to generate many sequences from only 401 tables.
    PRMAN_INLINE RtFloat2 progressive2DSample(
        const unsigned int pattern,
        const unsigned int sample )
    {
        RtFloat2 result;
        float *randomTable;
        unsigned int t, s;
        const unsigned int nRandomTables = N_PMJ_TABLES; // 401
        const unsigned int tableSize = PMJ_TABLE_SIZE; // 1024
        const unsigned int totalTableSize = nRandomTables * tableSize;

        if (sample > totalTableSize) {
            // Resort to random when running out of table entries after
            // 401*1024 = 410624 samples with same pattern id
            result.x = RixRNGUtils::HashToRandom(sample, pattern * 0x51633e2d);
            result.y = RixRNGUtils::HashToRandom(sample, pattern * 0x68bc21eb);
            return result;
        }

        // Scramble the input pattern some more
        unsigned int pattern1 = HashToRandomUInt(pattern, 0x51633e2d);
        unsigned int pattern2 = HashToRandomUInt(pattern, 0x68bc21eb);
        unsigned int pattern3 = HashToRandomUInt(pattern, 0x02e5be93);
        unsigned int pattern4 = HashToRandomUInt(pattern, 0x967a889b);

        // Select which randomTable based on pattern1
        t = pattern1 % nRandomTables;
        assert(t < nRandomTables);

        // Select table entry.
        // Locally swap the order by swapping neighbor samples, groups of
        // two samples, groups of four samples, and groups of eight samples.
        // Local swapping does not affect the convergence properties of each
        // sequence, but decorrelates sequences so they can be combined to a
        // higher-dimensional sample (aka. "padding").
        // (Could also randomly offset starting index by 0/16/32/48 to further
        // reduce correlation between dimensions.)
        // When we have "used up" all 1024 samples in a table we start over
        // in the next table.
        s = sample + t * tableSize;
        if (pattern2 & 0x1) s = (sample & 0x1) ? s-1 : s+1;
        if (pattern2 & 0x2) s = (sample & 0x2) ? s-2 : s+2;
        if (pattern2 & 0x4) s = (sample & 0x4) ? s-4 : s+4;
        if (pattern2 & 0x8) s = (sample & 0x8) ? s-8 : s+8;
        s = s % totalTableSize; // to avoid running off end of randomTables

        // Lookup sample in table
        float **tables = (float**)pmjTables;
        randomTable = tables[1]; // 1 = 2D
        result.x = randomTable[2*s]; // progressive multijittered 2D
        result.y = randomTable[2*s+1];
        assert(0.0f <= result.x && result.x <= 1.0f); // 1.0 is okay here
        assert(0.0f <= result.y && result.y <= 1.0f);

        // Random (but consistent) flips
        //if (pattern3 & 0x1) result.x = 1.0f-result.x;
        //if (pattern3 & 0x2) result.y = 1.0f-result.y;
        //if (pattern3 & 0x4) std::swap(result.x, result.y);

        // Scramble bits of sample with bits of patterns, convert back to float
        result.x = fpScramble(result.x, pattern3);
        result.y = fpScramble(result.y, pattern4);

        // Ensure (bit-scrambled) values are strictly less than 1.0
        if (result.x > 0.999990f) result.x = 0.999990f;
        if (result.y > 0.999990f) result.y = 0.999990f;
        assert(0.0f <= result.x && result.x < 1.0f);
        assert(0.0f <= result.y && result.y < 1.0f);

        return result;
    }


    // Compute a progressive 3D PMJ sample
    PRMAN_INLINE RtFloat3 progressive3DSample(
        const unsigned int pattern,
        const unsigned int sample )
    {
        RtFloat3 result;
        float *randomTable;
        unsigned int t, s;
        const unsigned int nRandomTables = N_PMJ_TABLES; // 401
        const unsigned int tableSize = PMJ_TABLE_SIZE; // 1024
        const unsigned int totalTableSize = nRandomTables * tableSize;

        if (sample > totalTableSize) {
            // Resort to random when running out of table entries after
            // 401*1024 = 410624 samples with same pattern id
            result.x = RixRNGUtils::HashToRandom(sample, pattern * 0x51633e2d);
            result.y = RixRNGUtils::HashToRandom(sample, pattern * 0x68bc21eb);
            result.z = RixRNGUtils::HashToRandom(sample, pattern * 0x02e5be93);
            return result;
        }

        // Scramble the input pattern some more
        unsigned int pattern1 = HashToRandomUInt(pattern, 0x51633e2d);
        unsigned int pattern2 = HashToRandomUInt(pattern, 0x68bc21eb);
        unsigned int pattern3 = HashToRandomUInt(pattern, 0x02e5be93);
        unsigned int pattern4 = HashToRandomUInt(pattern, 0x967a889b);
        unsigned int pattern5 = HashToRandomUInt(pattern, 0xdeb189cf);

        // Select which randomTable based on pattern1
        t = pattern1 % nRandomTables;
        assert(t < nRandomTables);

        // Select table entry.  See comments in 2D version.
        s = sample + t * tableSize;
        if (pattern2 & 0x1) s = (sample & 0x1) ? s-1 : s+1;
        if (pattern2 & 0x2) s = (sample & 0x2) ? s-2 : s+2;
        if (pattern2 & 0x4) s = (sample & 0x4) ? s-4 : s+4;
        if (pattern2 & 0x8) s = (sample & 0x8) ? s-8 : s+8;
        s = s % totalTableSize; // to avoid running off end of randomTables

        // Lookup sample in table
        float **tables = (float**)pmjTables;
        randomTable = tables[2]; // 2 = 3D
        result.x = randomTable[3*s]; // progressive multijittered 3D
        result.y = randomTable[3*s+1];
        result.z = randomTable[3*s+2];
        assert(0.0f <= result.x && result.x <= 1.0f); // 1.0 is okay here
        assert(0.0f <= result.y && result.y <= 1.0f);
        assert(0.0f <= result.z && result.z <= 1.0f);

        // Random (but consistent) flips (could also swap xy xz yz)
        //if (pattern3 & 0x1) result.x = 1.0f-result.x;
        //if (pattern3 & 0x2) result.y = 1.0f-result.y;
        //if (pattern3 & 0x4) result.z = 1.0f-result.z;

        // Scramble bits of sample with bits of patterns, convert back to float
        result.x = fpScramble(result.x, pattern3);
        result.y = fpScramble(result.y, pattern4);
        result.z = fpScramble(result.z, pattern5);

        // Ensure (bit-scrambled) values are strictly less than 1.0
        if (result.x > 0.999990f) result.x = 0.999990f;
        if (result.y > 0.999990f) result.y = 0.999990f;
        if (result.z > 0.999990f) result.z = 0.999990f;
        assert(0.0f <= result.x && result.x < 1.0f);
        assert(0.0f <= result.y && result.y < 1.0f);
        assert(0.0f <= result.z && result.z < 1.0f);

        return result;
    }

public:
    virtual RtFloat  Sample1D(unsigned int i, const SampleCtx &rctx) {
        return progressive1DSample(rctx.patternid, rctx.sampleid);
    }
    virtual RtFloat2 Sample2D(unsigned int i, const SampleCtx &rctx) {
        return progressive2DSample(rctx.patternid, rctx.sampleid);
    }
    virtual RtFloat3 Sample3D(unsigned int i, const SampleCtx &rctx) {
        return progressive3DSample(rctx.patternid, rctx.sampleid);
    }

    virtual void MultiSample1D(unsigned int n, const SampleCtx *rctx, RtFloat *xis) {
        for(unsigned int i = 0; i < n; ++i) {
            xis[i] = progressive1DSample(rctx[i].patternid, rctx[i].sampleid);
        }
    }
    virtual void MultiSample2D(unsigned int n, const SampleCtx *rctx, RtFloat2 *xis) {
        for(unsigned int i = 0; i < n; ++i) {
            xis[i] = progressive2DSample(rctx[i].patternid, rctx[i].sampleid);
        }
    }
    virtual void MultiSample3D(unsigned int n, const SampleCtx *rctx, RtFloat3 *xis) {
        for(unsigned int i = 0; i < n; ++i) {
            xis[i] = progressive3DSample(rctx[i].patternid, rctx[i].sampleid);
        }

    }
};


#endif
