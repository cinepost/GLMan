#ifndef RixRNGInline_h
#define RixRNGInline_h
// $Revision: #8 $ $Date: 2014/12/10 $
//
// This file is intended solely for inclusion by RixInterfaces.h and should 
// note be included directly.  Here we define inline implementations of private
// RixRNG methods.  Conceptually the contents of this file are "opaque" but
// we provide them to deliver the highest performance.  Each release may
// differ from the last, so in order to obtain the new benefits, clients
// will need to recompile.
//
// These routines collectively implement progressive multi-jittered samples
// (PMJ) based on precomputed tables.  The progressive multi-jittered samples
// are related to the correlated multi-jittered samples described in Pixar 
// Technical Memo #13-01, "Correlated Multi-Jittered Sampling" 
// (http://graphics.pixar.com/library/MultiJitteredSampling/), but are
// progressive -- which is important for interactive/iterative rendering.
//
// Alternatively, you may use the fields in Ctx as inputs to your own 
// sampling sequence instead if you prefer.
//

#include <cassert>

/*
# ------------------------------------------------------------------------------
#
# Copyright (c) 2013-2014 Pixar Animation Studios. All rights reserved.
#
# The information in this file (the "Software") is provided for the
# exclusive use of the software licensees of Pixar.  Licensees have
# the right to incorporate the Software into other products for use
# by other authorized software licensees of Pixar, without fee.
# Except as expressly permitted herein, the Software may not be
# disclosed to third parties, copied or duplicated in any form, in
# whole or in part, without the prior written permission of
# Pixar Animation Studios.
#
# The copyright notices in the Software and this entire statement,
# including the above license grant, this restriction and the
# following disclaimer, must be included in all copies of the
# Software, in whole or in part, and all permitted derivative works of
# the Software, unless such copies or derivative works are solely
# in the form of machine-executable object code generated by a
# source language processor.
#
# PIXAR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
# ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT
# SHALL PIXAR BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES
# OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
# WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
# ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
# SOFTWARE.
#
# Pixar
# 1200 Park Ave
# Emeryville CA 94608
#
# ------------------------------------------------------------------------------
*/

namespace RixRNGUtils {

//
// Correlated Multi-Jittered samples -- see tech memo by Andrew Kensler
//

PRMAN_INLINE unsigned randomPermute(
    const unsigned value,
    const unsigned range,
    const unsigned scramble)
{
    unsigned mask = range - 1;
    mask |= mask >> 1;
    mask |= mask >> 2;
    mask |= mask >> 4;
    mask |= mask >> 8;
    mask |= mask >> 16;
    unsigned result = value;
    do
    {
        result ^= scramble;                 result *= 0xe170893d;
        result ^= scramble          >> 16;
        result ^= (result & mask) >>  4;
        result ^= scramble          >>  8;  result *= 0x0929eb3f;
        result ^= scramble          >> 23;
        result ^= (result & mask) >>  1;  result *= 1 | scramble >> 27;
                                            result *= 0x6935fa69;
        result ^= (result & mask) >> 11;  result *= 0x74dcb303;
        result ^= (result & mask) >>  2;  result *= 0x9e501cc3;
        result ^= (result & mask) >>  2;  result *= 0xc860a3df;
        result &= mask;
        result ^= result            >>  5;
    } while (result >= range);
    return (result + scramble) % range;
}

// Compute a repeatable random float in [0,1) based on value and scramble
PRMAN_INLINE float HashToRandom(
    const unsigned value,
    const unsigned scramble)
{
    unsigned result = value;
    result ^= scramble;
    result ^= result >> 17;
    result ^= result >> 10;  result *= 0xb36534e5;
    result ^= result >> 12;
    result ^= result >> 21;  result *= 0x93fc4795;
    result ^= 0xdf6e307f;
    result ^= result >> 17;  result *= 1 | scramble >> 18;
    return result * (1.0f / 4298115584.0f);
}

PRMAN_INLINE unsigned shufflePattern(const unsigned pattern,
                                         const unsigned scramble1 = 0xb2182ef5,
                                         const unsigned scramble2 = 0x1e1897a7)
{
    unsigned npattern = pattern * ((scramble1 << 1) | 1);
                                // All odds are coprime with 2^16.
    npattern += scramble2;
    return npattern;
}

// Compute a shuffled 1D CMJ sample
PRMAN_INLINE RtFloat shuffled1DSample(
    const unsigned pattern,
    const unsigned sample,
    const unsigned numSamples)
{
    assert(sample < numSamples);
    static float const almostOne = 1.0f - 2.0f * FLT_EPSILON;
    float invNumSamples = almostOne / numSamples;
    unsigned shuffled = randomPermute(sample, numSamples, pattern * 0xb6d1c549);
    float jitter = HashToRandom(sample, pattern * 0x2d7780d3);
    return (shuffled + jitter) * invNumSamples;
}

// Compute a shuffled 2D CMJ sample
PRMAN_INLINE RtFloat2 shuffled2DSample(
    const unsigned pattern,
    const unsigned sample,
    const unsigned numSamples,
    float const aspect = 1.0f)
{
    assert(sample < numSamples);
    unsigned numSamplesX = static_cast<unsigned>(sqrtf(numSamples * aspect));
    unsigned numSamplesY = (numSamples + numSamplesX - 1) / numSamplesX;
    static float const almostOne = 1.0f - 2.0f * FLT_EPSILON;
    float invNumSamplesXY = almostOne / (numSamplesX * numSamplesY);
    float invNumSamples = almostOne / numSamples;
    unsigned shuffled = randomPermute(sample, numSamples,
                                          pattern * 0x51633e2d);
    unsigned shuffledX = randomPermute(shuffled % numSamplesX, numSamplesX,
                                           pattern * 0x68bc21eb);
    unsigned shuffledY = randomPermute(shuffled / numSamplesX, numSamplesY,
                                           pattern * 0x02e5be93);
    float jitterX = HashToRandom(sample, pattern * 0x967a889b);
    float jitterY = HashToRandom(sample, pattern * 0x368cc8b7);

    RtFloat2 result;
    result.x = (shuffledX * numSamplesY + shuffledY + jitterX)*invNumSamplesXY;
    result.y = (shuffled + jitterY) * invNumSamples;

    return result;
}

// Compute a shuffled 3D CMJ sample
PRMAN_INLINE RtFloat3 shuffled3DSample(
    const unsigned pattern,
    const unsigned sample,
    const unsigned numSamples)
{
    // We don't currently know how to generate 3D CMJ samples, so just
    // combine a 2D and a 1D sample ("padding").
    RtFloat2 xy = shuffled2DSample(pattern, sample, numSamples);
    RtFloat z = shuffled1DSample(pattern, sample, numSamples);
    return RtFloat3(xy.x, xy.y, z);
}

};

#endif
