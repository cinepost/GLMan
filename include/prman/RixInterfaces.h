#ifndef RixInterfaces_h
#define RixInterfaces_h
/* $Revision: #16 $  $Date: 2015/03/11 $ */
/*
# ------------------------------------------------------------------------------
#
# Copyright (c) 2006-2015 Pixar Animation Studios. All rights reserved.
#
# The information in this file (the "Software") is provided for the
# exclusive use of the software licensees of Pixar.  Licensees have
# the right to incorporate the Software into other products for use
# by other authorized software licensees of Pixar, without fee.
# Except as expressly permitted herein, the Software may not be
# disclosed to third parties, copied or duplicated in any form, in
# whole or in part, without the prior written permission of
# Pixar Animation Studios.
#
# The copyright notices in the Software and this entire statement,
# including the above license grant, this restriction and the
# following disclaimer, must be included in all copies of the
# Software, in whole or in part, and all permitted derivative works of
# the Software, unless such copies or derivative works are solely
# in the form of machine-executable object code generated by a
# source language processor.
#
# PIXAR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
# ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT
# SHALL PIXAR BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES
# OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
# WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
# ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
# SOFTWARE.
#
# Pixar
# 1200 Park Ave
# Emeryville CA 94608
#
# ------------------------------------------------------------------------------
*/

#include "ri.h"
#include <stddef.h>     // for size_t


/** 
    \mainpage RixInterfaces API Reference
    \brief RixInterfaces are RenderMan interface extensions.  

    A RixInterface is simply a C++ class that provides a collection of related
    methods.  For example, the RixMessages class provides a standardized way
    to report errors and warnings with optional suppression of duplicate
    messages.

    An interface is obtained by calling the GetRixInterface() method 
    of a context with an identifier from the RixInterfaceId enum.
    For example, in a shader plugin:
    \code
    RixMessages* msgs = (RixMessages*) rslCtx->GetRixInterface(k_RixMessages);
    msgs->Warning("Are you sure about this?");
    \endcode
    The generic interface that is returned must be cast to the appropriate
    type before use.

    From a procedural plugin, first call 
    <a href="../rxextensions.html#interfaces">
    RxGetRixContext</a> to obtain a global context:
    \code
    RixContext* context = RxGetRixContext();
    RixMessages* msgs = (RixMessages*) context->GetRixInterface(k_RixMessages);
    \endcode

    From a librix client, first call RixGetContext to obtain a global
    context.
    \code
    RixContext* context = RixGetContext();
    RixMessages* msgs = (RixMessages*) context->GetRixInterface(k_RixMessages);
    \endcode

    Not all interfaces are available from all contexts.  For example, the
    global RixContext currently does not have access to RixLocalData.

    Interfaces should never be deleted.  Most interfaces are thread safe and
    can be used indefinitely.  For example, rather than fetching the
    RixMessages interface each time a warning is printed, a plugin can store
    the interface in a global variable and reuse it as needed.
    Some interfaces are transient, however: in particular, an RixStorage
    interface for per-thread or local data can be used only in the context
    from which it was obtained.

    For more information, browse the documentation for these classes:
    - RixContext
    - RixInterface
    - RixInterfaceId
    - RixXcpt
    - RixStorage
    - RixTokenStorage
    - RixThreadUtils 
    - RixMutex
    - RixMessages
    - RixStats 
    - RixTimer 
    - RixXmlFile
    - RixSubdivisionSurfaceEvaluation
    - RixSubdivisionMesh
    - RixSubdivisionFace
    - RixSubdivisionVertex
    - RixRIB
    - RixRIBParser
    - RixTexture2d
    - RixTexture
    - RixDeepTexture
    - RixMemoryPool
    - RixRenderState
    - RixSloInfo
    - RixRiCtl
    - RixSymbolResolver
    - RixLightingServices
    - RixGeoDebugger
    - RixShadeFunctions
    - RixTransform
    - RixResourceResolver
    - RixLPEInfo
*/

//! Identifiers for Rix interfaces.
enum RixInterfaceId 
{
    k_RixThreadUtils = 0,  ///< Id for RixThreadUtils interface.
    k_RixMessages,         ///< Id for RixMessages interface.
    k_RixStatsV1,          ///< Id for legacy RixStats interface.
    k_RixGlobalData,       ///< Id for global (per frame) RixStorage interface.
    k_RixThreadData,       ///< Id for per-thread RixStorage interface.
    k_RixLocalData,        ///< Id for local RixStorage interface.
    k_RixGlobalTokenData,  ///< Id for global TokenStorage interface.
    k_RixSubdivEvalV1,     ///< Id for legacy Subdiv interface, do not use.
    k_RixSessionData = 8,  ///< Id for per session RixStorage interface.
    k_RixXcpt,             ///< Id for interface to exception handling.
    k_RixRIB,              ///< Id for RixRIB interface.
    k_RixDeepTexture,      ///< Id for RixDeepTexture interface.
    k_RixSubdivisionSurfaceEvaluation, ///< Id for RixSubdivEval interface.
    k_RixRIBParser,        ///< Id for RIB Parser interface.
    k_RixTexture2d,        ///< Id for 2d Texture interface.
    k_RixStats,            ///< Id for RixStats interface.
    k_RixTimer,            ///< Id for RixTimer interface.
    k_RixAreaShadow,       ///< Id for RixAreaShadow interface.
    k_RixRNGDeprecated,    ///< Id for Rix random number generator interface.
    k_RixMemoryPool,       ///< Id for RixMemoryPool interface.
    k_RixRenderState,      ///< Id for RixRenderState interface.
    k_RixSloInfo,          ///< Id for RixSlo interface.
    k_RixRiCtl,            ///< Id for Riinterface.
    k_RixSymbolResolver,   ///< Id for SymbolResolver interface.
    k_RixLightingServices, ///< Id for lighting services interface.
    k_RixGeoDebugger,      ///< Id for geometric debugger interface.
    k_RixTexture,          ///< Id for New Texture-2D interface.
    k_RixShadeFunctions,   ///< Id for Shade functions interface.
    k_RixTransform,        ///< Id for Transformation interface.
    k_RixResourceResolver, ///< Id for ResourceResolver interface.
    k_RixLPEInfo,          ///< Id for RixLPEInfo interface.
    k_RixCustomLPE,        ///< Id for RixCustomLPE interface.
};

/// Base class for all Rix interfaces.  
/// Interfaces should never be deleted.  Most interfaces are thread safe
/// and can be used indefinitely, but some interfaces can be used only in
/// the context from which they were obtained.
class RixInterface 
{
public:
    /// Get the version number of this interface.  Different interfaces
    /// might have different version numbers in a given release.
    virtual int GetVersion() const { return m_version; }

protected:
    /// Version number of this interface.
    int m_version;

    /// Interfaces should not be constructed by users.  
    RixInterface(int version) : m_version(version) { }

    /// Interfaces should not be deleted by users.  
    virtual ~RixInterface() { }
};

/// Rix interfaces are obtained from an RixContext.  Not all interfaces are
/// available from a given RixContext.  For example, the global RixContext does
/// not permit access to RixLocalData. In some library-only configurations
/// you may be able to get ahold of an interface directly.
class RixContext 
{
public:
    /// Get the specified interface from this context.  The generic interface
    /// that is returned must be cast to the appropriate type before use.
    virtual RixInterface* GetRixInterface(RixInterfaceId id) const = 0;

    /// Destructor is for internal use only
    virtual ~RixContext() { }
};


/// The primary means to comprehend exceptional conditions within
/// Rix is to handle messages generated by the library components. 
/// Clients should subclass RixXcptandler and register the object
/// with the RixContext. Now they must carefully monitor the msg 
/// stream for severe conditions that might effect the use of the 
/// interfaces.  In addition, lower-grade diagnostics should be 
/// reported through application-specific logging facilities.
class RixXcpt : public RixInterface
{
public:
    /// A base class characterizing the required interface  
    /// for xcpt handlers.
    class XcptHandler 
    {
    public:
        virtual void HandleXcpt(int code, int severity, const char *msg) = 0;
        virtual void HandleExitRequest(int code) = 0;

    protected:
        virtual ~XcptHandler() {}
    };

    /// Register your msg handler to receive exceptions and diagnostics
    /// produced through the use of the Rix interfaces.  Multiple handlers
    /// can be registered.
    virtual void Register(XcptHandler *) = 0;

    /// Unregister a msg handler. 
    virtual void Unregister(XcptHandler *) = 0;

protected:
    RixXcpt() : RixInterface(1) { }
};

/// A class that encapsulates a mutual exclusion object.
/// These are created via the RixThreadUtils interface.
/// This object can be used to lock access to shared data
/// to prevent contention from multiple threads.
///
/// NOTE: This is not a high performance implementation; for
///       best performance one should utilize native platform
///       locks.
class RixMutex 
{
public:
    /// Virtual destructor
    virtual ~RixMutex() { }

    /// Lock access
    virtual void Lock() = 0;
    
    /// Unlock and allow access 
    virtual void Unlock() = 0;
};


/// This object is used to create a RixMutex object
/// that can be used for locking access to shared 
/// global memory
class RixThreadUtils : public RixInterface 
{
public:
    /// Get a new RixMutex object.  NOTE: It must be deleted.
    virtual RixMutex* NewMutex() const = 0;

protected:
    /// Constructor is for internal use only.
    RixThreadUtils() : RixInterface(1) { }
};


/// An object that can be used to print warnings, errors,
/// or info in a thread safe way from within the renderer
class RixMessages : public RixInterface 
{
public:
    /**
        Report an error, with printf-style formatting.  For example:
        \code
            ReportError("Plugin failed, status %d", status);
        \endcode
        Duplicate error messages are suppressed.
    */
    virtual void Error(const char* format, ...) = 0;

    /// Report an error, with no suppression of duplicate messages.
    virtual void ErrorAlways(const char* format, ...) = 0;

    /// Report a warning, suppressing duplicate messages.
    virtual void Warning(const char* format, ...) = 0;

    /// Report a warning, with no suppression of duplicate messages.
    virtual void WarningAlways(const char* format, ...) = 0;

    /// Report information, suppressing duplicate messages.
    virtual void Info(const char* format, ...) = 0;

    /// Report information, with no suppression of duplicate messages.
    virtual void InfoAlways(const char* format, ...) = 0;

protected:
    /// Constructor is for internal use only.
    RixMessages() : RixInterface(1) { }
};

/// Interface for sampling a high-resolution representation of the current
/// time.  Primarily useful for statistics gathering of timing information
/// for plugins that operate within the renderer. In a multicore environment
/// time sampling is a little challenging and can incur overhead. To support 
/// multithreaded operation (i.e. for RslPlugin shadeops, procprims, rifs),
/// the standard idiom is to measure the time differential across a single
/// code execution block.  The value should be stored in a per-thread 
/// (lockless) context then summed across threads when a total is required. 
/// Note, these totals can exceed "user time".
/// 
class RixTimer : public RixInterface
{
public:
    /// Return a high resolution time sample 
    virtual RtUInt64 SampleTime() = 0;
    /// Convert a high res time interval to seconds of time
    virtual float ConvertIntervalToSeconds(RtUInt64 interval) = 0;

protected:
    RixTimer() : RixInterface(1) {}
};

/// An XML file handle, which is passed to a statistics reporter (see
/// RixStats::AddReporter).
class RixXmlFile 
{
public:
    /// Write arbitrary XML.  No encoding is performed, so be careful to avoid
    /// the use of special characters (e.g. the less-than symbol).  Users are
    /// encouraged to generate XML that matches the RenderMan statistics XML
    /// schema (e.g. to enable use of the default XML stylesheet).  See
    /// Application Note #43 (Using XML Frame Statistics) for details.
    virtual void WriteXml(const char* format, ...) = 0;

    /// Write arbitrary text to XML file, encoding special characters 
    /// like "&lt".
    virtual void WriteText(const char* format, ...) = 0;

    /// Virtual destructor
    virtual ~RixXmlFile() { }

    // Helper functions for writings stats.
    void WriteStat(char const *name, char const *desc, int value)
    {
        WriteXml("<int name=\"%s\"", name);
        if (desc) WriteXml(" description=\"%s\"", desc);
        WriteXml("> %i </int>\n", value);
    }

    void WriteStat(char const *name, char const *desc, RtUInt64 value)
    {
        WriteXml("<int name=\"%s\"", name);
        if (desc) WriteXml(" description=\"%s\"", desc);
        WriteXml("> %llu </int>\n", value);
    }

    void WriteStat(char const *name, char const *desc, float value)
    {
        WriteXml("<float name=\"%s\"", name);
        if (desc) WriteXml(" description=\"%s\"", desc);
        WriteXml("> %f </float>\n", value);
    }

    void WriteStat(char const *name, char const *desc, char const *value)
    {
        WriteXml("<string name=\"%s\"", name);
        if (desc) WriteXml(" description=\"%s\"", desc);
        WriteXml("> %s </string>\n", value);
    }

    void WriteTime(char const *name, char const *desc, float time)
    {
        WriteXml("<timer name=\"%s\"", name);
        if (desc) WriteXml(" description=\"%s\"", desc);
        WriteXml("><elapsed>%f</elapsed></timer>\n", time);
    }
};

/// Interface for including user statistics in XML file.  Thread safe.
///
/// Plugins can report elapsed time and peak memory usage statistics via
/// AddTimerStat and AddMemoryStat.  Other user-defined statistics can be
/// reported via AddReporter.  If statistics are enabled, plugin statistics
/// are reported at the end of each frame, after the built-in statistics are
/// reported.
///
/// Note that shader plugins must take care to ensure thread safety when
/// recording statistics in global variables. Controlling access with a mutex
/// is straightforward. Alternatively, statistics can be recorded in
/// per-thread data and then combined at the end of a frame. See the RSL
/// Plugin application note or the reference documentation for
/// RslContext::SetThreadData for more information.
class RixStats : public RixInterface 
{
public:
    /// Add a timer statistic, which is simply a pointer to a float into which
    /// the plugin has accumulated timing information (in seconds).  
    /// The name must be a valid XML token; the description may be empty.
    /// A duplicate call with the same name as a previously added statistic is
    /// ignored (a warning is generated if a different pointer is specified).
    /// The name and description are copied.
    virtual void AddTimerStat(float* seconds, const char* name,
                              const char* description) = 0;

    /// Add a generic statistic via a subclass of the SimpleStat class 
    /// interface.  Rix takes ownership of the SimpleStat object and may 
    /// destroy the object when the Rix session changes state. A duplicate 
    /// call with the same name as a previously added statistic is ignored 
    /// and will be deleted. We use TgUInt64 as the information exchange
    /// since it's is both portably and can hold large numbers.
    /// AddSimpleStat returns 0 on success, non-zero on failure.
    class SimpleStat
    {
    public:
        enum Fmt
        {
            k_fmtAsTimeInterval,
            k_fmtAsMemory,
            k_fmtAsUInt,
            k_fmtAsInt,
            k_fmtAsFloat
        };
        virtual ~SimpleStat() {}
        virtual void Reset() = 0;
        virtual const char *GetName() = 0;
        virtual const char *GetDescription() = 0;
        virtual void GetResults(RtUInt64 *result, Fmt *fmt) = 0;
    };
    virtual int AddSimpleStat(SimpleStat *)=0;

    /// Add a memory statistic, which is simply a pointer to a size_t into
    /// which the plugin has accumulated memory usage information (in bytes).
    /// The name must be a valid XML token; the description may be empty.
    /// A duplicate call with the same name as a previously added statistic is
    /// ignored (a warning is generated if a different pointer is specified).
    /// The name and description are copied.
    virtual void AddMemoryStat(size_t* bytes, const char* name, 
                               const char* description) = 0;

    /// A reporting function takes a RixXmlFile and writes to it using
    /// WriteXml and WriteText.  
    typedef void (*Reporter)(class RixXmlFile* file);
    typedef void (*ReporterCtx)(void *ctx, class RixXmlFile *);

    /**
        Register a statistics reporter, which is called at the end of each
        frame after built-in statistics are reported (if statistics are
        enabled).  Duplicate calls with the same reporter are ignored.
        Here is an example of a simple reporting function:
        \code
        void myReporter(RixXmlFile* file)
        {
           file->WriteXml ("<stats name=\"myPlugin\">\n");
           file->WriteXml ("    <int name=\"count\"> %i </int>\n", myCounter);
           file->WriteXml ("    <string name=\"info\">\n");
           file->WriteText("        %s\n", myInfo);
           file->WriteXml ("    </string>\n");
           file->WriteXml ("</stats>\n");
        }
        \endcode
    */
    virtual void AddReporter(Reporter func) = 0;
    virtual void AddReporterCtx(ReporterCtx func, void *ctx) = 0;

    /// Add a file to the fileLog statistic. This filename
    /// will be copied and reported alongside all the other
    /// files in the fileLog. By convention // is used to
    /// distinguish the search path from the absolute path
    /// of the filename being logged.
    virtual void AddFileLogStat(const char *filename, const char *path) = 0;

protected:
    /// Constructor is for internal use only.
    RixStats() : RixInterface(3) { }
};

/// A cleanup function can be associated with data in RixStorage.
typedef void (*RixCleanupFunc)(RixContext* context, void* data);

/**
    RixStorage allows plugins to store and share arbitrary data
    by associating it with an arbitrary key.  
    For example, a shader plugin might share per-thread data as follows:
    \code
    RixStorage* storage = (RixStorage*) 
        rslContext->GetRixInterface(k_RixThreadData);
    void* mydata = storage->Get("mydata");
    if (mydata == NULL) {
        mydata = MakeData();
        storage->Set("mydata", mydata, CleanupData);
    }
    \endcode
    
    This code operates as follows:
    - Get the per-thread data storage interface from the RslContext.
    - Look up the key to see if the data already exists.
    - If not, allocate the data and save it in per-thread storage.
    - The specified cleanup function is called when the thread exits
      (typically at the end of a frame).

    Per-thread storage is thread-safe, but all other storage must be locked,
    for example the per-grid storage below is locked:
    \code
    RixStorage* storage = (RixStorage*) rslCtx->GetRixInterface(k_RixLocalData);
    storage->Lock();
    void* myglobal = storage->Get("myglobal");
    if (myglobal == NULL) {
        myglobal = MakeData();
        storage->Set("myglobal", myglobal, CleanupData);
    }
    storage->Unlock();
    \endcode

    Per-thread storage can also be used from the global RixContext,
    as in the example below:
    \code
    RixContext *rixContext = RxGetRixContext();
    RixStorage* storage = (RixStorage*) 
        rixContext->GetRixInterface(k_RixThreadData);
    void* mydata = storage->Get("mydata");
    if (mydata == NULL) {
        mydata = MakeData();
        storage->Set("mydata", mydata, CleanupData);
    }
    \endcode

    A cleanup function has a prototype like the following:
    \code
    void myCleanup(RixContext* context, void* data);
    \endcode
    The RixContext argument allows the cleanup function to obtain interfaces
    for reporting errors, etc.  Note that a cleanup function for per-thread
    data can access the per-thread RixStorage interface (e.g. for maintaining
    memory usage statistics).  But per-thread storage is not accessible in a
    cleanup function for per-frame or per-session data.
*/
class RixStorage : public RixInterface 
{
public:
    /// Get the data associated with the given key, or NULL if there is none.
    virtual void* Get(const char* key) = 0;

    /// Set the data associated with the given key, along with an optional
    /// cleanup function.  Any previously associated data is discarded
    /// (calling its cleanup function, if any).  The key is copied.
    virtual void Set(const char* key, void* data, 
                     RixCleanupFunc cleanup = NULL) = 0;

    /// Clear any data associated with the given key, calling its cleanup
    /// function (if any).
    virtual void Clear(const char* key) = 0;

    /// Lock this object.  (Unnecessary unless it's used for global storage.)
    virtual void Lock() = 0;

    /// Unlock this object.
    virtual void Unlock() = 0;

protected:
    /// Constructor is for internal use only.
    RixStorage() : RixInterface(1) { }
};


/**
    RixTokenStorage allows a string to be stored as a token in a manner 
    which is safe with respect to the lifetime of the plugin, and shaders 
    which might use strings passed back from the plugin
*/
class RixTokenStorage : public RixInterface 
{
public:
    /// Get a token for a given string.
    /// The disposal of the input is up to the caller (you must free input,
    /// if it was malloced)
    /// The user should not attempt to dispose of the resulting token,
    /// which may then be passed as a result of an Rsl Plugin
    virtual const char *GetToken(const char *input) = 0;

protected:
    /// constructor for internal use only
    RixTokenStorage() : RixInterface(1) { }
};

/**
    RixTexture2d may perform filtered texture map lookups using one or
    four point or filter region versions of the corresponding 
    shading language shadeops.

    Each function takes a string specifying a texture filename, points 
    specifying the region to be textured, and an optional parameter list. 
    nchannels of texture data are retrieved starting at firstchannel, 
    and stored in ``result``. 

    The data pointers for input and results should be interleaved. 

    TexturePoints1V filters the texture map lookup using smooth derivatives. 
    If smooth derivatives are not available, it reverts to using the 
    four-point call with the provided s and t used for all four points.

    PTexturePointsFrV will apply ptexture using a filter region
    and PTexturePointsV will use the native ptexture() interface.
*/
class RixTexture2d : public RixInterface
{
public:
    enum resultType
    {
        k_floatResult,
        k_integerResult,
        k_stringResult,
        k_colorResult,
        k_normalResult,
        k_vectorResult,
        k_pointResult,
        k_hpointResult,
        k_mpointResult,
        k_matrixResult
    };

    /// For a given texture filename and a given query string,
    /// return in result, resultlen, resulttype, and resultcount
    /// the contents of the texture info query. If the query succeeds
    /// the return code will be zero.
    virtual int TextureInfo(const RtString filename, const char *query,
                            void *result, int resultlen, 
                            resultType *resulttype, int *resultcount,
                            int faceindex = -1)=0;

    /// Corresponds to the single-point version of the RSL texture()
    /// call. Additional arguments to the texture function are provided
    /// via the token / params pairs.
    virtual int TexturePoints1V(const RtString filename, RtInt nPoints,
                                RtInt firstchannel, RtInt nchannels, 
                                RtFloat *s, RtFloat *t, RtFloat *result, 
                                RtInt n, RtToken tokens[], RtPointer parms[])=0;

    /// Corresponds to the four-point version of the RSL texture()
    /// call. Additional arguments to the texture function are provided
    /// via the token / params pairs.
    virtual int TexturePoints4V(const RtString filename, RtInt nPoints,
                                RtInt firstchannel, RtInt nchannels, 
                                RtFloat *s0, RtFloat *t0, 
                                RtFloat *s1, RtFloat *t1,
                                RtFloat *s2, RtFloat *t2, 
                                RtFloat *s3, RtFloat *t3, 
                                RtFloat *result, RtInt n, RtToken tokens[],
                                RtPointer parms[])=0;

    /// Corresponds to the filterregion version of the RSL texture()
    /// call. Additional arguments to the texture function are provided
    /// via the token / params pairs.
    virtual int TexturePointsFrV(const RtString filename, RtInt nPoints,
                                RtInt firstchannel, RtInt nchannels, 
                                RtFloat *fr, RtFloat *result, 
                                RtInt n, RtToken tokens[], RtPointer parms[])=0;

    /// Corresponds to the filterregion version of the RSL ptexture()
    /// call. Additional arguments to the ptexture function are provided
    /// via the token / params pairs.
    virtual int PTexturePointsFrV(const RtString filename, RtInt nPoints,
                                  RtInt firstchannel, RtInt nchannels, 
                                  RtFloat *faceId, RtFloat *fr, 
                                  RtFloat *result,
                                  RtInt n, RtToken tokens[], 
                                  RtPointer parms[])=0;

    /// Corresponds to the derivative version of the RSL ptexture()
    /// call. Additional arguments to the ptexture function are provided
    /// via the token / params pairs.
    virtual int PTexturePointsV(const RtString filename, RtInt nPoints,
                                RtInt firstchannel, RtInt nchannels, 
                                RtFloat *faceId, 
                                RtFloat *u, RtFloat *v, 
                                RtFloat *du1, RtFloat *dv1,
                                RtFloat *du2, RtFloat *dv2,
                                RtFloat *result,
                                RtInt n, RtToken tokens[], 
                                RtPointer parms[])=0;

protected:
    /// constructor for internal use only
    RixTexture2d() : RixInterface(3) { }
};

/**
    RixTexture performs filtered texture map lookups using a
    texture coordinate and a region over which to filter. This
    interface is ideally suited for use with path tracing.

    The data pointers for input and results (including
    derivative results) should be interleaved. 

    This interface also provides the ability to obtain the 
    derivatives at a given texture lookup, which is useful for
    bump mapping.

    NOTE: Currently only FilterType::Bilinear and 
          FilterType::Bspline supports the derivative 
          capability.
*/
class RixTexture : public RixInterface
{
public:
    enum ErrType {
        Ok = 0,
        FileNotFound,
        PartNotFound,
        InvalidFaceIndex,
        TextureAccessErr,
        InvalidDerivatives,
        InvalidFilter,
        InvalidFile
    };

    struct TxProperties {
    public:
        /// Texture type
        enum TextureType {
            texture = 0, 
            ptexture,        
            latlong, 
            cubeface,
            shadow,
            deepshadow,
        };

        /// Create TxProperties with initial defaults
        TxProperties () 
            : version(1),
              fileHandle(NULL),
              nchannels(0),
              channelTypes(NULL),
              nparts(0),
              width(0),
              height(0),
              type(texture)
        { }

        int version;            // Version of this struct
        RtPointer fileHandle;   // If NULL, the file could not be acquired
        int nchannels;          // The # of channels in the texture
        unsigned char *channelTypes; // The types of the channels
                                     // 0 - unknown
                                     // 1 - 8  bit
                                     // 2 - 16 bit
                                     // 3 - 32 bit
                                     // 4 - float
                                     // 5 - half
        int nparts;             // The number of parts present
        int width, height;      // Width and height of texture
        TextureType type;       // What type of texture?
    };

    struct TxParams {
    public:
        /// Filter selection
        enum FilterType {
            Nearest = 0,   // *WARNING* disables MIPMAP! No filtering
            Box,           // Fast "box" like filter
            Bilinear,      // Slower, supports derivatives
            Bspline,       // Slower bicubic filter, supports derivatives
            Mitchell,      // Negative lobed, fast, bicubic filter
            Catmullrom,    // Negative lobed, fast, bicubic filter
            Gaussian,      // Gaussian fast filter
            Lagrangian     // Fastest (SSE based) filter
        };

        /// Create TxParams with initial defaults
        TxParams () 
            : version(1),
              nchannels(1),
              firstchannel(0),
              lerp(true),
              filter(Box),
              sblur(NULL),
              tblur(NULL),
              sblurVarying(true),
              tblurVarying(true),
              swidth(1.0f), 
              twidth(1.0f),
              fill(0.0f),
              faceIndex(NULL) 
        { }

        int version;           // Version of this struct
        int nchannels;         // The number of channels to lookup      
        int firstchannel;      // The channel to start the lookup     
        bool lerp;             // Should MIP levels be interpolated
        FilterType filter;     // Which filter should be used 
        const float *sblur;    // Amount of blur to apply to lookup
        const float *tblur;   
        bool sblurVarying;     // Is the blur uniform?
        bool tblurVarying; 
        float swidth;          // Multiplier for filter radius
        float twidth; 
        float fill;            // Color to fill missing channels  
        float *faceIndex;      // a faceIndex to access ptexture
    };

    /// All texture access must acquire a texture first.
    /// A non-zero return code means the texture specified
    /// by filename could not be acquired. NOTE: The filename
    /// string storage must be persistent. If it is not,
    /// the call will create a persistent string. If the
    /// filename is persistent (e.g: from a GetToken() call),
    /// then true can be used to make this call more efficient. 
    virtual int AcquireTexture (
                    const char *filename,
                    TxProperties &txProperties,
                    bool persistentFilename = false) = 0; 


    /// Once a texture has been acquired, we can then acquire
    /// a part by part index, the partProperties will
    /// reflect the properties of the multi-part texture.
    virtual int AcquireTexturePart (
                    int partIndex, 
                    TxProperties const &txProperties,
                    TxProperties &partProperties) = 0; 


    /// All texture access should release a texture as soon
    /// as it is finished looking up values.
    virtual int ReleaseTexture (TxProperties const &txProperties) = 0;


    /// Lookup filtered texture results over nPoints from a texture
    /// obtained with AcquireTexture(). The lookup point is provided by stIn. 
    /// The radius of the texture filter at the lookup point is provided by 
    /// stRadius. The results are placed in result.
    ///
    /// An optional runFlags array can be used to prevent lookups at a 
    /// given point by setting the value of the flag at a given point to 0.
    ///
    /// A non-zero return code, specified by ErrType is returned on error.
    virtual int Texture (
                    TxProperties const &txProperties, 
                    TxParams const &txParams,
                    RtInt nPoints,
                    RtFloat2 const *st,
                    RtFloat const *stRadius,
                    RtFloat *result, 
                    int *runFlags = NULL) = 0;


    /// Lookup filtered texture results over nPoints from a texture
    /// obtained with AcquireTexture(). The lookup point is provided by stIn. 
    /// The derivatives of the texture results can be obtained by passing
    /// non-NULL pointers for dresultds and dresultdt. The filter radius is
    /// computed from the bi-variate derivatives provided by the caller.
    /// (And then usually scaled by du/dv before being passed to this call).
    ///
    /// An optional runFlags array can be used to prevent lookups at a 
    /// given point by setting the value of the flag at a given point to 0.
    ///
    /// A non-zero return code, specified by ErrType is returned on error.
    ///
    /// NOTE:
    ///   Currently only the Bspline and Bilinear filters provide 
    ///   support for derivatives results.
    virtual int TextureDerivatives (
                    TxProperties const &txProperties, 
                    TxParams const &txParams,
                    RtInt nPoints,
                    RtFloat2 const *st,
                    RtFloat const *dsdu,
                    RtFloat const *dtdu,
                    RtFloat const *dsdv,
                    RtFloat const *dtdv,
                    RtFloat *result, 
                    RtFloat *dresultds, RtFloat *dresultdt,
                    int *runFlags = NULL) = 0;

    /// Lookup filtered ptexture results over nPoints from a ptexture
    /// obtained with AcquireTexture(). The lookup point is provided by stIn. 
    /// The radius of the texture filter at the lookup point is provided by 
    /// uRadius and vRadius. The results are placed in result.
    ///
    /// An optional runFlags array can be used to prevent lookups at a 
    /// given point by setting the value of the flag at a given point to 0.
    ///
    /// The call cannot be used to obtain texture results from ptexture,
    /// the Texture() or TextureDerivatives() call must be used instead. 
    /// 
    /// A non-zero return code, specified by ErrType is returned on error.
    virtual int Ptexture (
                    TxProperties const &txProperties, 
                    TxParams const &txParams,
                    RtInt nPoints,
                    RtFloat2 const *uv,
                    RtFloat const *uWidth,
                    RtFloat const *vWidth,
                    RtFloat *result, 
                    int *runFlags = NULL) = 0;


    /// Read the whole texture into a buffer at a given MIP level.
    /// The user of the API must provide the appropriately allocated
    /// buffer to place the results into. 
    //  NOTE: No filtering is applied to the data being read.
    virtual int TextureData (
                    TxProperties const &txProperties,
                    TxParams const &txParams,
                    int mipLevel,
                    int cubeFace,
                    void *result) = 0;

protected:
    /// constructor for internal use only
    RixTexture() : RixInterface(1) { }
};

/// RixShadeFunctions provides a general interface containing functions useful
/// for developing patterns for shading. Currently offers 3 types of noise in
/// 1D, 2D, 3D, and 4D as well as spline solving and evaluation.
class RixShadeFunctions : public RixInterface
{
public:
    /// Noise
    virtual RtFloat Noise(RtFloat  in) = 0;
    virtual RtFloat Noise(RtFloat2 const &in) = 0;
    virtual RtFloat Noise(RtFloat3 const &in) = 0;
    virtual RtFloat Noise(RtFloat3 const &in, RtFloat inF) = 0;

    virtual RtFloat3 Noise3(RtFloat  in) = 0;
    virtual RtFloat3 Noise3(RtFloat2 const &in) = 0;
    virtual RtFloat3 Noise3(RtFloat3 const &in) = 0;
    virtual RtFloat3 Noise3(RtFloat3 const &in, RtFloat inF) = 0;

    /// Periodic Noise
    virtual RtFloat PNoise(RtFloat  in, RtFloat period) = 0;
    virtual RtFloat PNoise(RtFloat2 const &in, RtFloat2 const &period) = 0;
    virtual RtFloat PNoise(RtFloat3 const &in, RtFloat3 const &period) = 0;
    virtual RtFloat PNoise(RtFloat3 const &in, RtFloat inF, 
                           RtFloat3 const &period, RtFloat periodF) = 0;

    virtual RtFloat3 PNoise3(RtFloat  in, RtFloat period) = 0;
    virtual RtFloat3 PNoise3(RtFloat2 const &in, RtFloat2 const &period) = 0;
    virtual RtFloat3 PNoise3(RtFloat3 const &in, RtFloat3 const &period) = 0;
    virtual RtFloat3 PNoise3(RtFloat3 const &in, RtFloat inF, 
                             RtFloat3 const &period, RtFloat periodF) = 0;

    /// Cell Noise
    virtual RtFloat CellNoise(RtFloat  in) = 0;
    virtual RtFloat CellNoise(RtFloat2 const &in) = 0;
    virtual RtFloat CellNoise(RtFloat3 const &in) = 0;
    virtual RtFloat CellNoise(RtFloat3 const &in, RtFloat inF) = 0;

    virtual RtFloat3 CellNoise3(RtFloat  in) = 0;
    virtual RtFloat3 CellNoise3(RtFloat2 const &in) = 0;
    virtual RtFloat3 CellNoise3(RtFloat3 const &in) = 0;
    virtual RtFloat3 CellNoise3(RtFloat3 const &in, RtFloat inF) = 0;

    /// Spline solver and evaluator
    enum SplineType {
        Bezier = 0, 
        BSpline,        
        Hermite, 
        Linear,
        Catmullrom
    };

    virtual RtFloat SolveSpline (SplineType type, 
                                 RtFloat const knot[],
                                 RtInt nKnots,
                                 RtFloat a) = 0;
    virtual RtFloat EvalSpline  (SplineType type, 
                                 RtFloat const knot[],
                                 RtInt nKnots,
                                 RtFloat a) = 0;
    virtual RtFloat3 EvalSpline3(SplineType type,
                                 RtFloat3 const knot[],
                                 RtInt nknot,
                                 RtFloat a) = 0;
 
protected:
    /// constructor for internal use only
    RixShadeFunctions() : RixInterface(1) { }
};

/// RixTransform provides transformation routines that operate
/// over named coordinate systems in the renderer.
class RixTransform : public RixInterface
{
public:
    /// Transform an array of points 'p' of size 'n' from
    /// 'fromspace' to 'tospace' at a given 'time'. 
    /// 0 is returned on success and non-zero if the transform
    /// could not be made.
    virtual RtInt TransformPoints(RtConstString fromspace, 
                                  RtConstString tospace,
                                  RtInt n, RtPoint p[], RtFloat time) = 0;

    /// Transform an array of points 'p' of size 'n' via matrix 'm'.
    virtual void  TransformPoints(RtMatrix m, RtInt n, RtPoint p[]) = 0;

    /// Take 'fromspace' and 'tospace' and 'time' and return
    /// matrix 'm' representing that transformation.
    /// 0 is returned on success and non-zero if the transform
    /// could not be made.
    virtual RtInt TransformMatrix(RtConstString fromspace, 
                                  RtConstString tospace,
                                  RtFloat time, RtMatrix m) = 0;
 
protected:
    /// constructor for internal use only
    RixTransform() : RixInterface(1) { }
};

/// Compute areashadow for a grid. Unlike other Rix interfaces, RixAreaShadow
/// is a thin layer on top of an underlying RSL shadeop, areashadow(). The array
/// of filter regions or surface points must be the same size as the implicit grid.
/// 
/// On the other hand, the number of light samples is unconstrained. Light
/// samples are points on the light (as opposed to directions). The RSL optional
/// outputs perRayTransmission, perRayL, perRayLLength are mandatory here, but
/// result is not. If not needed, pass a null pointer to result.

class RixAreaShadow : public RixInterface
{
public:

/// Filter regions on a surface.
virtual int AreaShadowFrV(RtInt nMaps, const RtString mapNames[],
                          RtFloat* filterRegions,
                          RtInt nLightSamples,
                          RtPoint*  lightPoints,
                          RtColor*  result,
                          RtColor*  perRayResult,
                          RtVector* perRayL,
                          RtFloat*  perRayLMag,
                          RtInt n, RtToken tokens[], 
                          RtPointer parms[]) = 0;

/// Points on a surface.
virtual int AreaShadowPV(RtInt nMaps, const RtString mapNames[],
                         RtFloat* points,
                         RtInt nLightSamples,
                         RtPoint*  lightPoints,
                         RtColor*  result,
                         RtColor*  perRayResult,
                         RtVector* perRayL,
                         RtFloat*  perRayLMag,
                         RtInt n, RtToken tokens[], 
                         RtPointer parms[]) = 0;

protected:
    /// constructor for internal use only
    RixAreaShadow() : RixInterface(1) { }
};

/// An interface for allocating memory from a memory pool for the purposes
/// of shading.  Due to the repetitive, recursive and threaded nature of
/// shader execution, it may be faster and easier to allocate memory
/// from this pool rather than the standard malloc heap.  The constraints
/// imposed by this memory allocator are:
///     - you shouldn't retain a reference to allocated memory beyond
///       the advertised lifetime
///     - you shouldn't free, delete or release the memory (it's automatic)
///     - you should use 'placement new' to assign the allocated memory blocks
///       for use by C++ objects.
///     - no destructors will be called on any C++ objects in the block.
///     - this interface isn't available in RIS mode, you should rely
///       on the built-in memory services of RixIntegratorContext and
///       RixShadingContext.
class RixMemoryPool : public RixInterface
{
public:
    enum BlockLifetime
    {
        k_EvaluationLifetime, 
            // The duration of a single evaluation of the invoking plugin
            // function, method or execution block. Usually RixAlloca
            // should be preferred over EvaluationLifetime unless the 
            // memory required exceeds the amounts reasonable for the 
            // stack.
        k_ShadeContextLifetime,
            // the duration of a full shader evaluation
    };

    // Allocate will return 0 either the requested lifetime is not supported
    // in the current context or if the pool is exhausted.  The latter 
    // condition is generally not recoverable. 
    virtual void *Allocate(size_t numbytes, BlockLifetime) = 0;

protected:
    RixMemoryPool() : RixInterface(1) { }
};

/// An interface for discovering the current state of the renderer.
class RixRenderState : public RixInterface
{
public:
    struct RendererInfo
    {
        const char *renderer;
        const char *version;
        float versionNumber;
        RtInt versionCode[4];
        char _reserved[32];
    };
    /// Provides information about the renderer.
    virtual int GetRendererInfo(RendererInfo *) = 0;

    struct FrameInfo
    {
        FrameInfo() : _vers(2) {}
        enum t_integrationMode
        {
            k_distribution,
            k_pathtrace,
        };

        enum t_displayStyle
        {
            k_partialPixels,
            k_finalPixels
        };

        int frame;
        int pixelSamples[2];
        int nthreads;
        float shutter[2]; // when shutter values are equal, no motion-blur
        t_integrationMode integrationMode;
        bool rerendering;
        struct
        {
            int nDisplays; // indexes for GetDspyInfo
            int resolution[2];
            t_displayStyle displayStyle;
        } displayState;

        int _vers; 

        // added in version 2
        // integrator settings are only non-null in RIS mode
        char const *integratorName; 
        char const *integratorPath;
        class RixIntegratorEnvironment const *integratorEnv;

        char _reserved[32];
    };

    /// Provides information about the current frame.  Returns 0 on
    /// success and a non-zero error code indicating failure.
    virtual int GetFrameInfo(FrameInfo *) = 0;

    struct DspyInfo
    {
        char const *name;
        char const *type;
        char const *mode;
        char _reserved[32];
    };
    /// Returns details about a given dspy.  dspyid must
    /// be between 0 and FrameInfo::ndspy-1.
    virtual int GetDspyInfo(int dspyId, DspyInfo *) = 0;

    enum RayType
    {
        k_rtInvalid=0,
        k_rtCamera,       /* primary visibility ray from a camera */
        k_rtLight,        /* photon ray directly from a light source */
        k_rtSpecular,     /* specularly reflected ray/photon */
        k_rtDiffuse,      /* diffusely reflected ray/photon */
        k_rtTransmission, /* shadow ray */
        k_rtDirectlight,  /* directlighting ray */
        k_rtNumRayTypes
    };

    enum ShadingIntent
    {
        k_siInvalid=0,
        k_siShadeGrid,
        k_siShadeRay,
        k_siCache,
        k_siNumShadingIntents
    };

    struct RayCtxInfo
    {
        bool rayhit; /* Camera rays can either be reyes or raytraced */
        RayType raytype;
        char const *raylabel;
        int depth, diffusedepth, speculardepth, shadowdepth, subsurfacedepth;
        int integratorIteration; // always 0 when in distribution integration
        int currentDecimation, maxDecimation; // only nonzero during rerendering
        ShadingIntent shadingIntent;
        char _reserved[32];
    };

    /// Provides information about the current shading context's ray tracing
    /// state. Returns 0 on success and a non-zero error code indicating
    /// failure.
    virtual int GetRayCtxInfo(RayCtxInfo *) = 0;

    ///
    /// GetAttribute, GetOption, return the current values of the 
    /// named Attribute or Option.
    ///
    /// The caller passes in a buffer and it is filled-in with the
    /// resulting requested info.  Return value is 0 on success, or
    /// -1 if name can't be found, or N if the supplied buffer was
    /// too short and needs to be at least N bytes long.  Caller
    /// supplies the addresses of several other return values which
    /// are filled in:  resulttype is the RixRenderState::Type of
    /// the values put into the result buffer, and resultcount is
    /// the number of those (multibyte) items.
    ///
    enum Type
    {
        k_Float, 
        k_Integer, 
        k_StringV, 
        k_Color,
        k_Normal, 
        k_Vector, 
        k_Point, 
        k_HPoint,
        k_MPoint, 
        k_Matrix
    };
    virtual int GetOption(const char *name, void *result, int resultlen,
                        Type *resulttype, int *resultcount) = 0;

    virtual int GetAttribute(const char *name, void *result, int resultlen,
                        Type *resulttype, int *resultcount) = 0;

    ///
    /// GetAttrIdNameStack returns a list of names representing the
    /// attribute scopes enclosing the current Ri stream position.
    /// Caller provides memory into which the renderer writes the
    /// name at each level.
    /// Positive returncode represents success and will be less than
    /// the provided maximum length. idstack[0] is the 'innermost' scope.
    /// idstack[returnval-1] is the outermost scope.
    /// Nonpositive return codes represent failure, the magnitude of the
    /// result represents the size of the memory block needed to store a 
    /// result.  A return value of 0 indicates other exceptional (error)
    /// conditions.
    virtual int GetAttrIdNameStack(char const *idstack[], unsigned maxlen) = 0;



protected:
    RixRenderState() : RixInterface(2) { }
};

class RixSymbolResolver : public RixInterface
{
public:
    /// ResolveToken returns a standard token for the provided string.
    /// May be useful to ensure that globally tokens are valid across
    /// shared-object boundaries in the case where the RixContext is
    /// obtained via RixGetContextViaRMANTREE.
    virtual RtToken ResolveToken(char const *nm) = 0;

    enum SymbolGroup
    {
        k_PixelFilter   = 0,
        k_Basis         = 1,
        k_Procedural    = 2,
        k_ErrorHandler  = 3
    };
    //
    /// ResolveSymbol returns a reference to the requested standard
    /// Ri symbol excluding tokens. May be useful to ensure that globally 
    /// procedure references are valid across shared-object boundaries in the 
    /// case where the RixContext is obtained via RixGetContextViaRMANTREE. 
    /// Symbol names follow the "C" entry point. 
    /// So: 
    ///     RiPixelFilter(RiBoxFilter, 2.0, 2.0) 
    ///  becomes:
    ///     RtFloatFunc boxFilter = rs->ResolveSymbol("RiBoxFilter");
    ///     ri->PixelFilter(boxFilter, 2.0, 2.0);
    ///  Useful to obtain references to standard spline basis functions,
    ///  error handlers and procedural primitives.
    virtual RtPointer ResolveSymbol(const char *nm, SymbolGroup group) = 0;

protected:
    RixSymbolResolver() : RixInterface(1) {}
};

class RixResourceResolver : public RixInterface
{
public:
    enum ResourceType
    {
        k_Shader=0,
        k_Texture,
        k_Archive,
        k_Display,
        k_Procedural,
        k_RifFilter,
        k_RixPlugin
    };

    /// GetResourcePaths returns a ':' separated string representing
    /// filesystem directories to search for the requested resource type.
    virtual char const *GetResourcePaths(ResourceType) = 0;

    /// ResolveResource searches for the specified resource and
    /// returns the fully qualified filename of the resource.
    /// If the resource can't be found nonzero error code is returned.  
    /// Note that we follow the same file extension inference rules as does 
    /// the renderer. Thus nm can be a relative filepath and may or 
    /// may not require a file extension according to standard 
    /// RenderMan conventions. If it works in RIB it should work here.
    /// Result should be allocated large enough to contain a fully-qualified
    /// pathname... Should the resulting file be found but not fit in the
    /// provided buffer, we return a positive error code indicated the required
    /// length.  We return a negative error code, if the file not be found.
    virtual int ResolveResource(ResourceType, char const *nm,
                                char result[], int maxlen) = 0;

protected:
    RixResourceResolver() : RixInterface(1) {}
};

class RixGeoDebugger : public RixInterface
{
public:
     virtual void EmitVector(RtVector3 v, RtColorRGB c)=0;
     virtual void EmitPoint(RtPoint3 p, RtColorRGB c)=0;
     virtual void EmitPointNormal(RtPoint3 p, RtNormal3 n, RtColorRGB c)=0;
     virtual void EmitLine(RtPoint3 p1, RtPoint3 p2, RtColorRGB c)=0;
     virtual void EmitBound(RtPoint3 pmin, RtPoint3 pmax, RtColorRGB c)=0;
     virtual void Clear()=0;
     virtual void Flush()=0;

protected:
    RixGeoDebugger() : RixInterface(1) {}
};

/// The following entry points may be available with standalone libraries.
extern "C" {
    PRMANAPI class RixContext *RixGetContext();
    PRMANAPI class RixContext *RixGetContextViaRMANTREE(const char*rmantree=0L,
                                                        bool printerror=true);
}

typedef RtInt RixLPEToken;

/// An interface to find out information related to light path 
/// expressions (LPEs).
class RixLPEInfo : public RixInterface 
{
  public:
    ///
    /// GetLpeIdByName returns the integer lobe index given the lobe
    /// name and booleans indicating whether it is a discrete/specular/reflect
    /// lobe. 
    virtual int GetLpeIdByName(bool discrete, bool specular, bool reflect, 
                               unsigned char lobeId, char const *name) = 0;

    /// 
    /// Return the maximum potential number of diffuse and specular lobe 
    /// indices.
    virtual int GetNumPotentialDiffuseLobes() = 0;
    virtual int GetNumPotentialSpecularLobes() = 0;
    virtual RixLPEToken StringToToken(char const *str) = 0;

protected:
    RixLPEInfo() : RixInterface(1) {}
};

class RixLPEState;
class RixShadingContext;

// This is a callback routine for use with the 
// RixCustomLPE::RegisterScatterCallback() and 
// RixCustomLPE::InvokeScatterCallbacks(), described in more detail below.
typedef void (*RixLPECallback)(void *userData,
                               RixLPEState *lpeState, 
                               RixShadingContext const *sCtx, 
                               int sCtxIndex,
                               RtColorRGB const &thruput,
                               RtColorRGB const *lgtTrans, 
                               bool firstContribution);

/// An interface to lookup and match custom light path expressions (LPEs).
class RixCustomLPE : public RixInterface 
{
  public:

    // Use this method to return an integer identifier that corresponds to
    // a given Light Path Expression (LPE).
    virtual int LookupLPE(char const *lpeExpr) = 0;

    // This method returns true if the 'customLpe' integer identifier
    // (which should be obtained by calling LookupLPE()) matches the current
    // ray hit, returning true or false along with the cumulative path 
    // throughput corresponding to the custom LPE. This method should typically
    // be called from within a registered "transition" callback routine 
    // (see RegisterScatterCallback() below).
    virtual bool MatchesLPE(int customLpe, 
                            RixLPEState *lpeState, 
                            RtColorRGB &thruput) = 0;

    // Use this method to register a "scatter" callback. Each scattering
    // event along the ray path counts as a "scatter" event (that is, each 
    // ray-geometry intersection hit point that results in light being 
    // scattered throughout the scene). Ater registering a scatter callback,
    // the callback routine will be invoked at each scattering event. Within
    // a scatter callback routine one might make a call to the MatchesLPE()
    // method in order to determine whether a particular custom LPE matches
    // the current ray path history.
    virtual void RegisterScatterCallback(RixLPECallback callbackFunc, 
                                         void *userData = NULL) = 0;

    // Calling this method will invoke all registered scatter callback routines.
    // Typically this method is only called internally by the core rendering
    // code (and typically end-user code would not need to call this method 
    // directly). Instead this routine is called indirectly via the RixLPE 
    // interface whenever there is a scattering event.
    virtual void InvokeScatterCallbacks(RixLPEState *lpeState,
                                        RixShadingContext const *sCtx,
                                        int sCtxIndex,
                                        RtColorRGB const &thruput,
                                        RtColorRGB const *lgtTrans, 
                                        bool firstContribution) = 0;

protected:
    RixCustomLPE() : RixInterface(1) {}
};

#endif  // RIX_INTERFACE_H
