#ifndef RixProjection_h
#define RixProjection_h
/* $Revision: #2 $  $Date: 2014/12/10 $
# ------------------------------------------------------------------------------
#
# Copyright (c) 2014 Pixar Animation Studios. All rights reserved.
#
# The information in this file (the "Software") is provided for the
# exclusive use of the software licensees of Pixar.  Licensees have
# the right to incorporate the Software into other products for use
# by other authorized software licensees of Pixar, without fee.
# Except as expressly permitted herein, the Software may not be
# disclosed to third parties, copied or duplicated in any form, in
# whole or in part, without the prior written permission of
# Pixar Animation Studios.
#
# The copyright notices in the Software and this entire statement,
# including the above license grant, this restriction and the
# following disclaimer, must be included in all copies of the
# Software, in whole or in part, and all permitted derivative works of
# the Software, unless such copies or derivative works are solely
# in the form of machine-executable object code generated by a
# source language processor.
#
# PIXAR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
# ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT
# SHALL PIXAR BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES
# OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
# WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
# ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
# SOFTWARE.
#
# Pixar
# 1200 Park Ave
# Emeryville CA 94608
#
# ------------------------------------------------------------------------------
*/

#include "RixShading.h"

struct RtRayGeometry;
class RixProjectionContext;

/// RixProjection plugins characterize camera and lens projections.  They
/// are responsible for turning stratified random samples into rays.  These
/// are then traced as the primary camera rays and passed along with any
/// hits to the RixIntegrator.  The main job of the plugin is to implement
/// the Project() method.
///
/// Note that if your RIB defines an RiProjection using one of the built-in
/// projections before a plugin RiProjection, the built-in one will be
/// applied first.  This means that your plugin may act more as a filter
/// over the built-in projection rather than a totally new one.  For
/// example, you may choose to alter the time samples to achieve special
/// shutter effects while leaving the ray positions alone.

class RixProjectionEnvironment
{
public:
    enum DeepMetric
    {
        k_cameraZ=0,
        k_rayLength=1
    };

    RixProjectionEnvironment()
        : m_version(1),
          deepMetric(k_cameraZ)
    {
    }

    RtInt m_version;

    /// Expresses depth metric to use for samples in deep output.  Set to
    /// k_cameraZ for standard perspective or orthographic projections.
    /// Use k_rayLength for spherical, cylindrical, etc. with -Z rays.

    DeepMetric deepMetric;

    char _reserved[32];
};

class RixProjection : public RixShadingPlugin
{
public:
    virtual int GetInterface() const { return k_RixProjection; }

    /// Per-plugin-instance scope is enclosed in Init/Finalize block.
    /// Plugins can report errors during init and return non-zero status.
    /// These will be called at plugin load/unload.

    virtual int Init(RixContext &ctx, char const *pluginPath) = 0;
    virtual RixSCParamInfo const *GetParamTable() = 0;
    virtual void Finalize(RixContext &ctx) = 0;

    /// Setup and teardown methods invoked in the 'main thread'.
    /// These will be called before/after rendering a frame.  Note that
    /// for determining screen resolution and other information you may
    /// access the RixRenderState API from here.

    virtual void RenderBegin(RixContext &ctx, RixProjectionEnvironment &env,
                             RixParameterList const *parms) = 0;
    virtual void RenderEnd(RixContext &ctx) = 0;

    /// This optional method will be called from the main thread as state
    /// changes occur.  Perhaps the most interesting message here is the
    /// k_RixSCInstanceEdit.  This will be sent along with a new set of
    /// token/value pairs from the RIB when this projection is edited
    /// during rerendering.

    virtual void Synchronize(RixContext &ctx, RixSCSyncMsg syncMsg,
                             RixParameterList const *parms) {}
    // default implementation means optional override

    /// Project: is the primary entrypoint for this class.
    /// Maps a set of samples onto rays.  This will be invoked by the
    /// rendering threads and should be thread-safe and re-entrant.

    virtual void Project(RixProjectionContext &pCtx) = 0;

protected:
    RixProjection() : RixShadingPlugin( k_RixShadingVersion ) {}
    virtual ~RixProjection() {}
};

#define RIX_PROJECTIONCREATE \
 extern "C" PRMANEXPORT RixProjection *CreateRixProjection(char const *hint)

#define RIX_PROJECTIONDESTROY \
 extern "C" PRMANEXPORT void DestroyRixProjection(RixProjection *projection)


/// The RixProjectionContext bundles together the main inputs and outputs
/// from the RixProjection::Project() method and provides a few convenient
/// utility methods to help it do its work.

class RixProjectionContext : public RixContext
{
public:

    RtInt numRays;

    /// The screen samples represent samples in screen space with subpixel
    /// precision.  For typical wide screen images, these will be in the
    /// [-aspect,aspect)x[-1,1) rectangle.  The exact range depends on the
    /// combination of RiFormat, RiFrameAspectRatio, RiScreenWindow, and
    /// RiCropWindow settings.

    RtPoint2 *screen;

    /// The lens samples are the raw, canonical samples, uniformly
    /// distributed in the [0,1)^2 unit square.  The aperture samples are
    /// the lens samples warped into the [-1,1]^2 square with a density
    /// distribution that produces the bokeh and anamorphic DoF specified
    /// by the "aperture" and "dofaspect" parameters from the RiHider line.
    /// These are for your convenience.  You may ignore them if you wish.

    RtPoint2 *lens;
    RtPoint2 *aperture;

    /// Time samples are the raw, canonical samples, uniformly distributed
    /// in the [0,1) range.  The shutter samples are the time samples
    /// remapped, also in the [0,1) range, but with a density distribution
    /// according to the the shaped "shutteropening" parameter on the
    /// RiCamera line.  Both of these are interpreted relative to shutter
    /// open at 0 and shutter close at 1.  The projection may also alter
    /// the shutter values so long as they remain within [0,1).

    RtFloat *time;
    RtFloat *shutter;

    /// Projection plugin will normally use the above data to override the
    /// origin, direction, originRadius, and raySpread fields of the rays
    /// (they are initially populated by the built-in projection).  These
    /// fields are defined in terms of camera space with the camera
    /// centered at the origin and looking down the +Z axis.
    ///
    /// NOTE: the directions should either be normalized or zero!!!

    RtRayGeometry *rays;

    /// An optional tint to apply to the beauty channel of the shaded rays
    /// before pixel filtering.  Defaults to white (1,1,1) to leave them
    /// unchanged.  Plugins may change these to create vignetting,
    /// chromatic aberration, spectral bokeh, or other effects.

    RtColorRGB *tint;

    /// Utility methods to transform the rays in-place from one space
    /// to another.  Origins will be treated as points, and directions
    /// as vectors.  The current ray time values (see shutter) will be
    /// respected for single segment motion blur.

    virtual void TransformOrigins(char const *fromSpace,
                                  char const *toSpace) = 0;
    virtual void TransformDirections(char const *fromSpace,
                                     char const *toSpace) = 0;

protected:
    RixProjectionContext() : RixContext() {}
    virtual ~RixProjectionContext() {}
};

#endif
