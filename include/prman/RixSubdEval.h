#ifndef RixSubdEval_h
#define RixSubdEval_h
/* $Revision: #3 $ $Date: 2014/12/10 $
# ------------------------------------------------------------------------------
#
# Copyright (c) 2010-2014 Pixar Animation Studios. All rights reserved.
#
# The information in this file (the "Software") is provided for the
# exclusive use of the software licensees of Pixar.  Licensees have
# the right to incorporate the Software into other products for use
# by other authorized software licensees of Pixar, without fee.
# Except as expressly permitted herein, the Software may not be
# disclosed to third parties, copied or duplicated in any form, in
# whole or in part, without the prior written permission of
# Pixar Animation Studios.
#
# The copyright notices in the Software and this entire statement,
# including the above license grant, this restriction and the
# following disclaimer, must be included in all copies of the
# Software, in whole or in part, and all permitted derivative works of
# the Software, unless such copies or derivative works are solely
# in the form of machine-executable object code generated by a
# source language processor.
#
# PIXAR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
# ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT
# SHALL PIXAR BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES
# OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
# WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
# ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
# SOFTWARE.
#
# Pixar
# 1200 Park Ave
# Emeryville CA 94608
#
# ------------------------------------------------------------------------------
*/
#include "RixInterfaces.h"

class RixSubdivisionMesh;
class RixSubdivisionFace;
class RixSudivisionVertex;

/// This class is used to obtain SubdivisionMesh objects
class RixSubdivisionSurfaceEvaluation : public RixInterface 
{
public:
    /// Get a handle to subdivision surface previously created by the
    /// renderer.
    virtual RixSubdivisionMesh *GetSubdivisionMesh(const char *handle) = 0;

    /// Constructs a subdivision surface from local data.
    virtual RixSubdivisionMesh *CreateSubdivisionMesh(const RtToken mask,
        int nfaces, const int *nverts, const int *verts, int ntags,
        RtToken const *tags, int *ntagargs, int *intargs, float *floatargs,
        char * const *stringargs, int nparms, RtToken const *tokens,
        void **data) = 0;

    /// Destroys a subdivision surface.
    virtual void DestroySubdivisionMesh(RixSubdivisionMesh *mesh) = 0;
    
protected:
    /// Constructor is for internal use only.
    RixSubdivisionSurfaceEvaluation() : RixInterface(2) { }
};

/// An object that encapsulates a vertex on a subdivision mesh.
class RixSubdivisionVertex 
{
protected:    
    virtual ~RixSubdivisionVertex() { }

public:
    /// Returns the unique ID of this vertex. The ID is guaranteed to
    /// be unique amongst all other vertices present on the mesh.
    virtual int GetID() = 0;

    /// Returns the data index of this vertex. Unlike the ID, the data
    /// index is not guaranteed to be unique. The data index may be used
    /// to index into values returned by
    /// RixSubdivisionMesh::GetPackedVertexValues.
    virtual int GetDataIndex() = 0;
    
    /// Requests the current value of a primitive variable attached to
    /// this vertex. The variable cannot be a string, uniform, or
    /// facevarying detail; it can only be constant, varying, or
    /// vertex. (For uniform and facevarying variables, you must use
    /// RixSubdivisionFace methods.) Returns true if the data exists
    /// with the given name and width (in floats) and is of allowable
    /// type, false otherwise. Point-like data types will be returned
    /// in camera space.
    virtual bool GetValue(const RtToken name, int width, float *data) = 0;

    /// Requests the current value of a primitive variable attached to
    /// this vertex. The variable cannot be a string, uniform, or
    /// facevarying detail; it can only be constant, varying, or
    /// vertex. (For uniform and facevarying variables, you must use
    /// RixSubdivisionFace methods.) Returns true if the data exists
    /// with the given name and width (in floats) and is of allowable
    /// type, false otherwise. Point-like data types will be
    /// transformed to the requested space.
    virtual bool GetValue(const RtToken name, int width, const RtToken space, float *data) = 0;
};

/// An object that encapsulates a face on a subdivision mesh.
class RixSubdivisionFace {
protected:
    /// Virtual destructor
    virtual ~RixSubdivisionFace() { }

public:
    /// Returns the unique ID of this face. The ID is guaranteed to be
    /// unique amongst all other faces present on the mesh.
    virtual int GetID() = 0;
    
    /// Returns the number of vertices on the face.
    virtual int GetNumVertices() = 0;

    /// Returns the vertex belonging to the face. The vertex
    /// identifier must be greater than or equal to 0 and less than
    /// that returned by GetNumVertices().
    virtual RixSubdivisionVertex *GetVertex(int vertex) = 0;
    
    /// Returns the bounding box of the face in current space.
    virtual void GetBound(RtBound bound) = 0;

    /// Returns the bounding box of the face in the requested space.
    virtual void GetBound(const RtToken space, RtBound bound) = 0;

    /** Returns the neighboring face which shares the indicated edge,
        or NULL if no such face can be found (because this face
        is on a boundary, or the neighboring face has not yet come into 
        existence due to Subdivision). If a face is found, the
        reverseEdge parameter is set to be the edge value which can be
        used to find the original face. i.e:
        \code
        neighbor = face->GetNeighboringFace(edge, &reverseEdge);
        neighbor->GetNeighboringFace(reverseEdge) == face;
        \endcode
    */
    virtual RixSubdivisionFace *GetNeighboringFace(int edge,
                                                   int *reverseEdge = 0) = 0;

    /// Subdivides the face. Must be called in order for GetChildFace
    /// to return non-NULL results.
    virtual void Subdivide() = 0;

    /** Returns the child face associated with the indicated vertex
        index. Will return non-NULL results only after a face has been
        subdivided. If a child face is found, the childVertex parameter
        is set such that it can be used to find the vertex in the
        child face which is the direct subdivided child vertex of the
        parent vertex. i.e:
        \code
        child = face->GetChildFace(vertex, &childVertex);
        // child->GetVertex(childVertex) is the direct
        // subdivision child of face->GetVertex(vertex)
        \endcode
    */
    virtual RixSubdivisionFace *GetChildFace(int vertex,
                                             int *childVertex = 0) = 0;

    /// Returns the parent face. Returns NULL for top level (coarse)
    /// faces.
    virtual RixSubdivisionFace *GetParentFace() = 0;

    /// Requests the current value of a primitive variable at a given
    /// vertex on the face. The variable cannot be a string type, but
    /// can have any detail (constant, uniform, varying, facevarying,
    /// and vertex). Returns true if the data exists with the given
    /// name and width (in floats), false otherwise. "u" and "v" are
    /// special tokens that can also be supplied as names (with a
    /// corresponding width of 1), and will return the u/v values of
    /// the indicated vertex.  Point-like data types will be returned
    /// in camera space.
    virtual bool GetVertexValue(int vertex, const RtToken name, int width,
                                float *data) = 0;

    /// Requests the current value of a primitive variable at a given
    /// vertex on the face. The variable cannot be a string type, but
    /// can have any detail (constant, uniform, varying, facevarying,
    /// and vertex). Returns true if the data exists with the given
    /// name and width (in floats), false otherwise. "u" and "v" are
    /// special tokens that can also be supplied as names (with a
    /// corresponding width of 1), and will return the u/v values of
    /// the indicated vertex.  Point-like data types will be returned
    /// in the requested space.
    virtual bool GetVertexValue(int vertex, const RtToken name,
                                int width, const RtToken space,  float *data) = 0;
    

    /// Requests the current value of a uniform or constant string
    /// primitive variable attached to the face. Returns true if the
    /// data exists with the given name, false otherwise.
    virtual bool GetStringValue(const RtToken name, std::string& data) = 0;
    
    /// Returns true if the face has a limit surface (and
    /// EvaluateAtLimit can be successfully used), false
    /// otherwise. Faces that do not have a limit surface may require
    /// further subdivision.
    virtual bool HasLimitSurface() = 0;

    /// Evaluates the limit value of a primitive variable at the
    /// requested parametric location on the face. The variable cannot
    /// be a string type, but can have any detail (constant, uniform,
    /// varying, facevarying, and vertex). RI_N, RI_DPDU, RI_DPDV, and
    /// RI_DPDTIME are also allowed names and will return the
    /// appropriate geometric quantity in current space. Returns true
    /// only if the limit surface exists for this face and if the data
    /// exists with the given name and width (in floats), false
    /// otherwise. Point-like data types will be returned in camera
    /// space.
    virtual bool EvaluateAtLimit(float u, float v, const RtToken name,
                                 int width, float *data) = 0;

    /// Evaluates the limit value of a primitive variable at the
    /// requested parametric location on the face. The variable cannot
    /// be a string type, but can have any detail (constant, uniform,
    /// varying, facevarying, and vertex). RI_N, RI_DPDU, RI_DPDV, and
    /// RI_DPDTIME are also allowed names and will return the
    /// appropriate geometric quantity in current space. Returns true
    /// only if the limit surface exists for this face and if the data
    /// exists with the given name and width (in floats), false
    /// otherwise. Point-like data types will be transformed to the
    /// requested space.
    virtual bool EvaluateAtLimitMultiple(int nevals, float *u, float *v, const RtToken name,
                                         int width, const RtToken space, float *data) = 0;


    /// Sets the accuracy of limit surface evaluation. By default, for
    /// certain faces that cannot readily compute an exact answer, the
    /// accuracy of limit surface evaluation is determined by raster
    /// space projection and the current RiShadingRate setting. This
    /// may incur a large memory penalty for faces that are very close
    /// to the camera. Likewise, faces that are very far from the
    /// camera may not have enough accuracy. This heuristic can be
    /// controlled by calling SetLimitEvaluationAccuracy. The distance
    /// parameter specifies the desired frequency of evaluations
    /// measured in a particular space.
    virtual void SetLimitEvaluationAccuracy(const RtToken space, float distance) = 0;

    /// Indicates to the system that memory associated with the face
    /// may be released. This is optional (calling
    /// RixSubdivisionSurfaceEvaluation->DestroySubdivisionMesh on
    /// the associated mesh will always free all resources associated
    /// with all faces), but using Release() may allow for incremental
    /// memory clean up. After calling face->Release(), the
    /// RixSubdivisionFace pointer should be considered
    /// invalid, and the face should never be revisited, even via
    /// calls to Subdivide() or mesh->GetFace(). Furthermore, any
    /// vertices that were previously returned by calls to GetVertex()
    /// may potentially be invalidated by this call. Any children
    /// faces already in existence due to a previous call to
    /// face->GetChildFace() are themselves still valid, but their
    /// calls to GetParentFace() will now return NULL. Likewise, any
    /// parent of this face will now return NULL for the appropriate
    /// call to GetChildFace().
    virtual void Release() = 0;
};


/// An object that encapsulates a subdivision mesh.
class RixSubdivisionMesh {
protected:
    /// Virtual destructor
    virtual ~RixSubdivisionMesh() { }

public:
    /// Returns the type of subdivision used in the mesh.
    virtual RtToken GetMask() = 0;
    
    /// Returns the total number of faces on the mesh, including faces
    /// created through subdivision.
    virtual int GetNumFaces() = 0;

    /// Returns the number of top level faces on the mesh.
    virtual int GetNumCoarseFaces() = 0;

    /// Returns the number of vertices on the mesh.
    virtual int GetNumVertices() = 0;

    /// Returns the face with the given ID on the mesh. Returns NULL
    /// if no face with that ID exists on the mesh.
    virtual RixSubdivisionFace *GetFace(int id) = 0;

    /// Returns the vertex with the given ID on the mesh. Returns NULL
    /// if no face with that ID exists on the mesh.
    virtual RixSubdivisionVertex *GetVertex(int id) = 0;

    /// Subdivides the entire mesh to the indicated depth.
    virtual void Subdivide(int depth) = 0;

    /// Requests the number of vertices in each face in the mesh at the given
    /// depth, as well as the data indices of those vertices. The
    /// data indices are returned in packed form.
    virtual void GetPackedVertexDataIndices(int depth,
                                            std::vector<int> &vertexcounts,
                                            std::vector<int> &vertices) = 0;
    
    /// Requests the current values of a primitive variable at all
    /// available vertices on the mesh. The variable cannot be a
    /// string type, and must be of detail varying, vertex, or
    /// facevarying. Returns true if the data exists with the given
    /// name and width (in floats), false otherwise. Point like data
    /// types will be transformed to the requested space.
    virtual bool GetPackedVertexValues(const RtToken name, int width,
                                       const RtToken space,
                                       std::vector<float> &data) = 0;
};



#endif
