#ifndef RixIntegrator_h
#define RixIntegrator_h
/* $Revision: #22 $ $Date: 2014/12/10 $
# ------------------------------------------------------------------------------
#
# Copyright (c) 2013-2014 Pixar Animation Studios. All rights reserved.
#
# The information in this file (the "Software") is provided for the
# exclusive use of the software licensees of Pixar.  Licensees have
# the right to incorporate the Software into other products for use
# by other authorized software licensees of Pixar, without fee.
# Except as expressly permitted herein, the Software may not be
# disclosed to third parties, copied or duplicated in any form, in
# whole or in part, without the prior written permission of
# Pixar Animation Studios.
#
# The copyright notices in the Software and this entire statement,
# including the above license grant, this restriction and the
# following disclaimer, must be included in all copies of the
# Software, in whole or in part, and all permitted derivative works of
# the Software, unless such copies or derivative works are solely
# in the form of machine-executable object code generated by a
# source language processor.
#
# PIXAR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
# ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT
# SHALL PIXAR BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES
# OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
# WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
# ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
# SOFTWARE.
#
# Pixar
# 1200 Park Ave
# Emeryville CA 94608
#
# ------------------------------------------------------------------------------
*/

#include "RixShading.h"
#include "RixBxdf.h"
#include "RixRNG.h"

class RixIntegratorContext;
class RixLightingServices;
class RixLPE;

typedef unsigned int RixChannelId;

struct RixDisplayChannel
{
    RixChannelId id;
    enum ChannelStyle
    {
        k_ChannelName,
        k_ChannelExpression,
    } style;
    enum ChannelType
    {
        k_FloatChannel,
        k_RGBChannel,
        k_PointChannel,
        k_NormalChannel,
        k_IdChannel
    } type;
    RtConstString channel;
};

class RixDisplayServices
{
public:

    /// Accumulate a value into a given display channel for a given path
    /// sample.  This is accumulative; it may be called at each vertex
    /// along a light path to sum radiance throughput, for example.  A
    /// transmission through this sample to the geometry immediately behind
    /// can also be specified for alpha purposes.  If Splat() is called
    /// multiple times for a sample, we use the minimum transmittance.
    ///
    /// Note: if looping through points in a ShadingContext, you will
    /// likely want to use sctx.integratorCtxIndex[i] to get the ictxIndex.

    virtual void Splat(RixChannelId id, RtInt ictxIndex,
                       RtFloat const val, RtFloat const trans = 0.0f) = 0;
    virtual void Splat(RixChannelId id, RtInt ictxIndex,
                       RtColorRGB const val, RtFloat const trans = 0.0f) = 0;

    /// These are similar to Splat(), except they take a list of channels
    /// to accumulate to.  The same value will be accumulated into each.

    virtual void SplatMulti(RtInt nchans, RixChannelId const *ids,
                            RtInt ictxIndex,
                            RtFloat const val, RtFloat const trans=0.0f) = 0;
    virtual void SplatMulti(RtInt nchans, RixChannelId const *id,
                            RtInt ictxIndex,
                            RtColorRGB const val, RtFloat const trans=0.f) = 0;

    /// These are also similar to Splat(), except that they overwrite the
    /// existing value instead of accumulating.  This can be useful for
    /// AOVs that do not sum linearly.  The last write into the given
    /// channel will be the one that gets filtered into the pixel for this
    /// particular sample.  It is up to the user to manage their shader
    /// networks to avoid plugins fighting over the value.

    virtual void Write(RixChannelId id, RtInt ictxIndex,
                       RtFloat const val, RtFloat const trans = 0.0f) = 0;
    virtual void Write(RixChannelId id, RtInt ictxIndex,
                       RtColorRGB const val, RtFloat const trans = 0.0f) = 0;

    /// Get a list of available display channels.  These are normally
    /// provided to the integrator via the integration environment for it
    /// to inspect during startup.  However, we provide access here during
    /// runtime for more dynamic applications such as patterns and bxdfs
    /// which would like to do "writeaov"-like things.

    virtual void GetDisplayChannels(RtInt *numDisplays,
                                    RixDisplayChannel const **displays) = 0;

    /// Cancel the results of any calls made to Splat(), SplatMulti(), and
    /// Write() during this invocation of the integrator's Integrate()
    /// method.  This may be useful if an integrator produces poor
    /// estimates during a warmup period.

    virtual void DiscardIteration() = 0;

protected:
    virtual ~RixDisplayServices() {}
};

struct RtRayGeometry
{
    RtPoint3 origin;
    RtVector3 direction;
    RtFloat originRadius;
    RtFloat raySpread;
    RtFloat maxDist;
    RtInt integratorCtxIndex; // to find associated time, in IntegratorCtx
    RixShadingContext::Id shadingCtxId; 
    RtInt shadingCtxIndex; // to assign a per-ray index into the shading ctx
    RtInt rayId; // to assign orthogonal identifier to the ray
    RixBXLobeSampled lobeSampled; // RixBXLobeSampled

    // InitOrigination should be called after the ray geometry has been 
    // established for calls to GetNearestHit. In addition to setting
    // the origination context, we analyze the combination of lobeSampled
    // and Nn to determine whether a transmit event was a nominal enter 
    // or exit. Origination state allows rays to be back-tracked to
    // the original shading context for recovery of ray-path information.
    void InitOrigination(RixShadingContext const *sctx, RtNormal3 const *Ngn, 
                         int shadingIndex)
    {
        this->shadingCtxId = sctx->shadingCtxId;
        this->shadingCtxIndex = shadingIndex;
        this->integratorCtxIndex = sctx->integratorCtxIndex[shadingIndex];
        if(this->lobeSampled.GetTransmit())
        {
            bool entering = Dot(Ngn[shadingIndex], this->direction) <= 0.f;
            this->lobeSampled.SetEntering(entering);
        }
    }
    // InitTransmission is analogous to InitOriginaation but should
    // be used for Transmission rays. All transmission 'events' are
    // transmit events and lobeSampled is ill-defined (since lights
    // are responsible for producing most transmission rays).
    void InitTransmitOrigination(RixShadingContext const *sctx,
                                 int shadingIndex)
    {
        this->shadingCtxId = sctx->shadingCtxId;
        this->shadingCtxIndex = shadingIndex;
        this->integratorCtxIndex = sctx->integratorCtxIndex[shadingIndex];
        this->lobeSampled.Set(true /*discrete*/, false /*specular*/,
                              false /*transmit, not reflect*/,
                              false /* scattering */,
                              0 /*lpeid*/, 0 /*lobeid (unused)*/);
        this->lobeSampled.SetEntering(true);
    }


    // Compute ray spread for given reflection/transmission type, pdf, and
    // surface curvature.
    // Computed using two approaches:
    // 1) Ray spread based on roughness (pdf).  The ray spread from a flat
    //    rough surface depends on roughness: the higher roughness the lower
    //    the pdf in a given direction; here we map the pdf to a ray spread
    //    using a heuristic mapping.
    // 2) Ray spread based on surface curvature.  The ray spread for reflection
    //    from a curved smooth surface is simple to compute using Igehy's 
    //    formula.
    // We set the overall rays spread to the max of these two.
    // (For rough curved surfaces a better answer might be larger than
    // the max -- perhaps the sum? -- but it's not 100% clear what the optimal
    // combined value should be.)
    void SetRaySpread(RixBXLobeSampled lobe,
                      RtFloat irayRadius, // incident ray radius at ray origin
                      RtFloat iSpread,   // incident ray spread at ray origin
                      RtFloat curvature, // local surface curvature
                      RtFloat fPdf,
                      bool lightPath = false)
    {
        RtFloat pdfSpread = 0.0f;
        RtFloat newSpread;

        // Compute ray spread based on pdf (and hence surface roughness)
        // (If Dirac delta, don't use pdf -- it is 1.0 by convention)
        if (!lightPath && lobe.GetSolidAngle() && fPdf > 0.0f)
        {
            // Inverse square is a heuristic that seems to work
            assert(fPdf > 0.0f && RixIsFinite(fPdf)); // avoid division by 0
            pdfSpread = 0.125f / sqrtf(fPdf);
        }

        // Compute ray spread based on surface curvature
        if (lobe.GetReflect())
        {
            // treat this as reflection

            //k_RixBXReflectSpecular
            //k_RixBXReflectGlossy
            //k_RixBXReflectDiffuse

            // Spread for specular reflection:
            // The new ray spread is the incident ray spread plus change induced
            // by local curvature.  The factor of 2 comes from differentiating
            // the formula for mirror reflection direction -- see [Igehy99].
            // Note that the spread can become negative for highly negative
            // curvature, for example a concave mirror.
            RtFloat curvatureSpread = iSpread + 2.0f*curvature*irayRadius;
            newSpread = std::max(curvatureSpread, pdfSpread);
        }
        else if (lobe.GetTransmit())
        {
            // treat this as refraction
    
            //k_RixBXTransmitSpecular
            //k_RixBXTransmitGlossy
            
            // Spread for specular transmission -- simpler than [Igehy99]
            // since we only need spread amount, not differential direction
            // vector:
            // newSpread = eta*iSpread - (1.0f-eta) * curvature * irayRadius;
            // This can give negative spread and focusing of the ray, with
            // the width of the ray increasing beyond the focus distance.
            // This is all good and fine, but we skip this effect for now.
            // For now: simply copy parent ray spread to avoid having to deal
            // with ior vs. 1/ior
            newSpread = std::max(iSpread, pdfSpread);

            //k_RixBXTransmitDiffuse

            // Use very conservative spread for diffuse reflection and
            // transmission: same as for specular/glossy reflection.
            // (Could do better if we know PixelSamples and diffusemultfactor:
            // compute ray solid angle = 2pi / (pixsam*diffmultfac)
        }
        else
        {
            // we have no idea what this ray is.. oops
            newSpread = iSpread;
        }

        // Disallow |newSpread| > 1
        if (newSpread > 1.0f) newSpread = 1.0f;
        if (newSpread < -1.0f) newSpread = -1.0f;
        assert(-1.0f <= newSpread && newSpread <= 1.0f);

        this->raySpread = newSpread;
    }
};

struct RtHitPoint
{
    RtPoint3 P;
    RtNormal3 Ng;
    RtFloat dist; // 0 means no-hit
    RtPoint2 uv;
    RtFloat filterSize; // used for texture filtering
    RtFloat mpSize; // used for ray-tracing bias calculation
};

class RixIntegratorEnvironment
{
public:
    enum SamplingModes
    {
        k_Invalid=0,
        k_Fixed=1,
        k_Adaptive=2,
        k_Incremental=4,

        k_AllModes = (k_Fixed|k_Adaptive|k_Incremental)
    };

    enum LightingModes
    {
        k_UnidirectionalLighting=0,
        k_BidirectionalLighting=1
    };

    RixIntegratorEnvironment()
        : m_version(1),
          maxIntegrateSize(1024),
          maxShadingCtxSize(1024),
          supportedSamplingModes(k_AllModes),
          lightingRequirements(k_UnidirectionalLighting),
          numDisplays(0),
          displays(0),
          wantsEmptyIntegrate(false),
          wantsIncrementBarrier(false),
          numRaysPerIncrement(-1),
          numIncrements(0),
          numBootstrapIncrements(0),
          lobesWanted(k_RixBXTraitsAllLobe),
          cameraMediumIOR(1.f),
          cameraMediumPriority(0)
    {
    }
    RtInt m_version;
    RtInt maxIntegrateSize;
    RtInt maxShadingCtxSize;
    SamplingModes supportedSamplingModes;
    LightingModes lightingRequirements;

    // Display state ------
    RtInt const numDisplays;
    RixDisplayChannel const * const displays;

    // Increment state ------
    bool wantsEmptyIntegrate;   // Expresses whether integrator requires
                                // empty integrate request in adaptive
                                // rendering modes.
    bool wantsIncrementBarrier; // Expresses whether integrator requires
                                // all threads to synchronize on each
                                // rendering increment.  This can
                                // impact performance; choose carefully
                                // whether this is really needed.
                                // See k_RixSCIncrementBarrier.
    RtInt const numRaysPerIncrement;
    RtInt const numIncrements;
    RtInt numBootstrapIncrements; // Used to request iterations which do not
                                  // contribute to the final result

    // Camera state ------
    RixBXLobeTraits lobesWanted; // Used to establish state for the first
                                 // "wavefront". Other calls to
                                 // GetNearestHit are parameterized
                                 // as integrator chooses.
    RtFloat cameraMediumIOR;     // defaults to 1.0f (air)
    RtInt cameraMediumPriority;  // defaults to 0

    char _reserved[32];
};

class RixIntegrator : public RixShadingPlugin
{
public:

    // RenderBegin/End: bounds a rendering session. This message
    // is delivered in the primary thread.
    virtual void RenderBegin(RixContext &ctx, RixIntegratorEnvironment &env,
                            RixParameterList const *parameterList) = 0;
    virtual void RenderEnd(RixContext &ctx) = 0;

    // Synchronize: is delivers occasional status information
    // from the renderer. Parameterlist contents depend upon the SyncMsg.
    // During rerendering, the parameterlist may contain updated integrator 
    // values.  Increment messages may deliver details about the increment.
    // This method is optional and the default implementation ignores all 
    // events.
    virtual void Synchronize(RixContext &ctx, RixSCSyncMsg syncMsg,
                            RixParameterList const *parameterList)
                    {}

    // Integrate: is the primary entrypoint for this class.  Integrators
    // are required to "Splat" radiance to the screen as characterized by
    // the RixIntegratorCtx::primaryRays and associates.
    virtual void Integrate(RtInt numGrps, RixShadingContext const *shadeCtxs[],
                           RixIntegratorContext &ictx) = 0;

protected:
    RixIntegrator() : RixShadingPlugin(k_RixShadingVersion) {}
    virtual ~RixIntegrator() {}
};

#define RIX_INTEGRATORCREATE \
 extern "C" PRMANEXPORT RixIntegrator *CreateRixIntegrator(const char *hint)

#define RIX_INTEGRATORDESTROY \
 extern "C" PRMANEXPORT void DestroyRixIntegrator(RixIntegrator *integrator)

class RixIntegratorContext : public RixContext
{
public:
    RtInt integratorCtxId; // unique identifier for integrator context
    RtInt numRays;
    RtRayGeometry *primaryRays;
    RixRNG *rngCtx;
    RtFloat *time;

    virtual RixDisplayServices *GetDisplayServices(int version = 1) const = 0;
    virtual RixLightingServices *GetLightingServices(int version = 1) const = 0;
    virtual RixLPE *GetRixLPE(int version = 1) const = 0;
    virtual RixIntegratorEnvironment const &GetEnv(int version = 1) const = 0;

    // The primary tools of an integrator are these ray-tracing methods.
    // Two versions of GetNearestHits are available:
    //  1) is the most common form - use it for indirect ray probes.
    //     Returns a list of shading groups:  collections of points
    //     an and associated shading context that has an bxdf that has
    //     bet setup for Evaluate/Generate samples.  Setting up a
    //     Bxdf is relatively expensive since it triggers the evaluation
    //     of its upstream pattern graph.
    //  2) is a ray probe.  No shading contexts are set up, only information
    //     about the geometric locale is returned. 
    // One version of GetTransmission is available and it of use in
    // bidirectional path-tracing applications to connect vertices.
    // RixLightingServices is responsible for transmission rays associated
    // with direct lighting samples so simple unidirectional path tracers
    // may have no need for this call.
    virtual void GetNearestHits(RtInt numRays, RtRayGeometry const *rays,
                                RixBXLobeTraits const &lobesWanted,
                                bool wantsMisses,
                                RtInt *numGrps, 
                                RixShadingContext const**shadeGrps,
                                // optional inputs:
                                char const *subset=NULL,
                                bool isLightPath = false)=0;
    virtual void GetNearestHits(RtInt numRays, RtRayGeometry const *rays,
                                RtHitPoint *hits,
                                // optional input:
                                char const *subset=NULL) = 0;
    virtual void GetTransmission(RtInt numRays, RtRayGeometry const *rays,
                                 RtColorRGB *trans, 
                                 // optional input:
                                 char const *subset=NULL) = 0;

    // ReleaseShadingCOntexts must be called to release the shadeGrps 
    // created via GetNearestHits(). ShadingContexts should not be 
    // released until after rays that originate from them have been traced.
    virtual void ReleaseShadingContexts(RtInt numGrps,
                                        RixShadingContext const **shadeGrps)=0;
    

    // Allocate and New are utility (fully inlined, templated) methods to
    // assist with tedious memory management tasks associated with the
    // memory pool of the IntegratorContext. Use Allocate for raw
    // allocations, New for allocations with default construction.
    //
    //   Usage: 
    //      RtColorRGB *result = ictx->Allocate<RtColorRGB>(100);

    enum MemCategory
    {
        k_IntegratorMem
    };
    virtual void *Allocate(size_t nObjs, size_t objsize, MemCategory) = 0;

    template <class T>
    T* Allocate(size_t nObjs)
    {
        T *mem = static_cast<T*>(Allocate(nObjs, sizeof(T), k_IntegratorMem));
        return mem;
    }

    template <class T>
    T *New(size_t nObjs)
    {
        T *mem = static_cast<T*>(Allocate(nObjs, sizeof(T), k_IntegratorMem));
        return new (mem) T[nObjs];
     }

protected:
    virtual ~RixIntegratorContext() {}
};

#endif
