#ifndef RixBxdfLobe_h
#define RixBxdfLobe_h
/* $Revision: #2 $ $Date: 2014/12/10 $
# ------------------------------------------------------------------------------
#
# Copyright (c) 2014 Pixar Animation Studios. All rights reserved.
#
# The information in this file (the "Software") is provided for the
# exclusive use of the software licensees of Pixar.  Licensees have
# the right to incorporate the Software into other products for use
# by other authorized software licensees of Pixar, without fee.
# Except as expressly permitted herein, the Software may not be
# disclosed to third parties, copied or duplicated in any form, in
# whole or in part, without the prior written permission of
# Pixar Animation Studios.
#
# The copyright notices in the Software and this entire statement,
# including the above license grant, this restriction and the
# following disclaimer, must be included in all copies of the
# Software, in whole or in part, and all permitted derivative works of
# the Software, unless such copies or derivative works are solely
# in the form of machine-executable object code generated by a
# source language processor.
#
# PIXAR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
# ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT
# SHALL PIXAR BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES
# OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
# WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
# ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
# SOFTWARE.
#
# Pixar
# 1200 Park Ave
# Emeryville CA 94608
#
# ------------------------------------------------------------------------------
*/

#include "RixInterfaces.h"

#include <cstring>
#include <cassert>

/// The maximum number of separate diffuse lobe AOVs.
static const int k_RixBXMaxNumDiffuseLobes = 4;

/// The maximum number of separate specular lobe AOVs.
static const int k_RixBXMaxNumSpecularLobes = 8;

/// This struct represents the characteristics of just one lobe of a bxdf.
struct RixBXLobeSampled
{
    /// Constructor; initializes the valid bit to false.
    PRMAN_INLINE RixBXLobeSampled();

    /// Constructor; initializes from serialization as unsigned short
    PRMAN_INLINE RixBXLobeSampled(unsigned short serialized);

    /// Constructor; sets all fields and sets the valid bit to true.
    PRMAN_INLINE RixBXLobeSampled(bool discrete, bool specular, bool reflect, 
                                  unsigned char lpeId, unsigned char lobeId);


    // CompareLobeID: returns true if rhs is the same as this lobeid.
    PRMAN_INLINE bool CompareLobeID(RixBXLobeSampled const &rhs)
    {
        return (fields.bits.valid && rhs.fields.bits.valid && 
                fields.bits.specular == rhs.fields.bits.specular && 
                fields.bits.lobeId == rhs.fields.bits.lobeId);
    }

    // Read-only accessors; these all verify that the valid bit is set before
    // returning true.
    PRMAN_INLINE bool GetValid() const;
    PRMAN_INLINE bool GetDiscrete() const;
    PRMAN_INLINE bool GetSolidAngle() const;
    PRMAN_INLINE bool GetDiffuse() const;
    PRMAN_INLINE bool GetSpecular() const;
    PRMAN_INLINE bool GetReflect() const;
    PRMAN_INLINE bool GetTransmit(bool *entering=NULL) const;
    PRMAN_INLINE bool GetEntering() const; // only valid for Transmit
    PRMAN_INLINE bool GetContinuation() const;
    PRMAN_INLINE bool GetScattering() const;
    PRMAN_INLINE unsigned char GetLpeId() const; 
    PRMAN_INLINE unsigned char GetLobeId() const; 

    // Set individual fields (only SetValid() changes the valid bit).
    PRMAN_INLINE void SetValid(bool val); 
    PRMAN_INLINE void SetDiscrete(bool val); 
    PRMAN_INLINE void SetSpecular(bool val); 
    PRMAN_INLINE void SetReflect();
    PRMAN_INLINE void SetTransmit(bool entering);
    PRMAN_INLINE void SetEntering(bool entering); // valid only for Transmit
    PRMAN_INLINE void SetLpeId(unsigned char val); 
    PRMAN_INLINE void SetLobeId(unsigned char val); 
    PRMAN_INLINE void SetContinuation(bool val);

    /// Set all fields and also sets the valid bit to true.
    PRMAN_INLINE void Set(bool vDiscrete, bool vSpecular, bool vReflect,
                          bool vContinuation,
                          unsigned char vLpeId, unsigned char vLobeid);
 
    // Convert to a serialized integral representation.
    PRMAN_INLINE unsigned short Serialize() const;

    struct Bitfield
    {
        unsigned short valid : 1;    /// 0 means all other fields are invalid
        unsigned short discrete : 1; /// 0 for solidangle measure, 
                                     /// 1 for discrete measure
        unsigned short specular : 1; /// 0 is diffuse, 1 is specular
        unsigned short reflect : 1;  /// 0 is refract, 1 is reflect
        unsigned short entering : 1; /// valid only on Transmit, computed by
                                     /// RtRayGeometry::InitOrigination() 
        unsigned short continuation : 1; /// 0 is scattering, 1 is continuation
        unsigned short lpeId : 3;    /// specular or diffuse lobe identity
        unsigned short lobeId : 3;   /// an optional user label for the sample
        unsigned short unused : 4;   /// unused (for now)
    };

    union Converter
    {
        Bitfield bits;
        unsigned short us;
    };

  private:
    Converter fields;
};

/// Use this method to return a RixBXLobeSampled struct using the name of 
/// the bxdf lobe. 
PRMAN_INLINE
RixBXLobeSampled RixBXLookupLobeByName(RixContext &ctx, 
                                       bool discrete, bool specular, 
                                       bool reflect, unsigned char lobeId, 
                                       char const *name);

/// This struct represents the characteristics of potentially several lobes 
/// of a bxdf in aggregate.
struct RixBXLobeTraits
{
    /// Constructor; initializes all fields to zero.
    PRMAN_INLINE RixBXLobeTraits();

    /// Constructor; initializes from serialization as unsigned short
    PRMAN_INLINE RixBXLobeTraits(unsigned serialized);

    /// Constructor; sets all fields.
    PRMAN_INLINE RixBXLobeTraits(bool discrete, bool reflect, bool transmit, 
                                 unsigned short D, unsigned short S);

    /// Constructor; sets all fields from a RixBXLobeSampled struct.
    PRMAN_INLINE explicit RixBXLobeTraits(RixBXLobeSampled lobe);

    // Read-only accessors; return individual fields.
    PRMAN_INLINE bool GetDiscrete() const;
    PRMAN_INLINE bool GetReflect() const;
    PRMAN_INLINE bool GetTransmit() const;
    PRMAN_INLINE bool GetContinuation() const;
    PRMAN_INLINE unsigned short GetDiffuse() const;
    PRMAN_INLINE unsigned short GetSpecular() const;

    PRMAN_INLINE bool GetMaxSpecularDepth() const;
    PRMAN_INLINE bool GetMaxDiffuseDepth() const;

    // Set individual fields.
    PRMAN_INLINE void SetDiscrete(bool val);
    PRMAN_INLINE void SetReflect(bool val);
    PRMAN_INLINE void SetTransmit(bool val);
    PRMAN_INLINE void SetContinuation(bool val);
    PRMAN_INLINE void SetMaxSpecularDepth(bool val);
    PRMAN_INLINE void SetMaxDiffuseDepth(bool val);
    PRMAN_INLINE void SetDiffuse(unsigned short bits);
    PRMAN_INLINE void SetSpecular(unsigned short bits);

    /// Zero all fields.
    PRMAN_INLINE void SetNone();

    /// Set all bits to true (except for the discreteSubset and 
    /// continuationSubset which are both set to zero;
    /// use SetDiscrete() / SetContinuation() to explicitly set the 
    /// discreteSubset and continuationSubset bits).
    PRMAN_INLINE void SetAll();

    /// Returns true if any diffuse or specular bits are set, and either
    /// the reflect or transmit bits are set.
    PRMAN_INLINE bool HasAny() const;

    /// Returns true if any diffuse bits are set, and either the reflect or
    /// transmit bits are set.
    PRMAN_INLINE bool HasAnyDiffuse() const;

    /// Returns true if any specular bits are set, and either the reflect or
    /// transmit bits are set.
    PRMAN_INLINE bool HasAnySpecular() const;

    // Convert to a serialized integral representation.
    PRMAN_INLINE unsigned Serialize() const;

    /// Bitwise AND all fields with the right-hand-side.
    PRMAN_INLINE RixBXLobeTraits const &operator &=(RixBXLobeTraits const &rhs);

    /// Bitwise OR all fields with the right-hand-side.
    PRMAN_INLINE RixBXLobeTraits const &operator |=(RixBXLobeTraits const &rhs);
 
    struct Bitfield
    {
        unsigned discreteSubset : 1;        /// 0 for solidangle measure, 
                                                  /// 1 for discrete measure
        unsigned reflectSubset : 1;         /// include reflected rays
        unsigned transmitSubset : 1;        /// include transmitted rays
        unsigned continuationSubset : 1;    /// include continuation rays
        unsigned D : k_RixBXMaxNumDiffuseLobes; /// 1 bit / diffuse lobe
        unsigned S : k_RixBXMaxNumSpecularLobes;/// 1 bit / specular lobe

        unsigned maxspeculardepth : 1;
        unsigned maxdiffusedepth : 1;
        unsigned unused : 14;   /// unused (for now)
    };

    union Converter
    {
        Bitfield bits;
        unsigned us;
    };

  private:
    Converter fields;
};

/// Bitwise AND all fields.
PRMAN_INLINE RixBXLobeTraits operator & (RixBXLobeTraits const &lhs, 
                                         RixBXLobeTraits const &rhs);

/// Bitwise OR all fields.
PRMAN_INLINE RixBXLobeTraits operator | (RixBXLobeTraits const &lhs, 
                                         RixBXLobeTraits const &rhs);

/// Some common lobe traits.
static const RixBXLobeTraits k_RixBXTraitsNullLobe
                                 (false, false, false, 0x0, 0x0);
static const RixBXLobeTraits k_RixBXTraitsReflectDiffuse
                                 (false, true, false, 0xF, 0x0);
static const RixBXLobeTraits k_RixBXTraitsReflectSpecular
                                 (false, true, false, 0x0, 0xFF);
static const RixBXLobeTraits k_RixBXTraitsTransmitDiffuse
                                 (false, false, true, 0xF, 0x0);
static const RixBXLobeTraits k_RixBXTraitsTransmitSpecular
                                 (false, false, true, 0x0, 0xFF);
static const RixBXLobeTraits k_RixBXTraitsAllDiffuse
                                 (false, true, true, 0xF, 0x0);
static const RixBXLobeTraits k_RixBXTraitsAllSpecular
                                 (false, true, true, 0x0, 0xFF);
static const RixBXLobeTraits k_RixBXTraitsAllReflect
                                 (false, true, false, 0x0F, 0xFF);
static const RixBXLobeTraits k_RixBXTraitsAllTransmit
                                 (false, false, true, 0x0F, 0xFF);
static const RixBXLobeTraits k_RixBXTraitsAllLobe
                                 (false, true, true, 0x0F, 0xFF);


struct RixBXActiveLobeWeights
{
    /// Constructor; sets the number of diffuse and specular lobes to zero.
    PRMAN_INLINE RixBXActiveLobeWeights();

    /// Constructor; sets all fields to the values given.
    PRMAN_INLINE RixBXActiveLobeWeights(RixBXLobeTraits lobeTraits, 
                                        int numDiffuseLobes,
                                        int numSpecularLobes, 
                                        RtColorRGB *diffuseLobes[], 
                                        RtColorRGB *specularLobes[],
                                        unsigned char diffuseLpeIds[],
                                        unsigned char specularLpeIds[], 
                                        int offset = 0);
    
    /// Copy constructor.
    PRMAN_INLINE RixBXActiveLobeWeights(RixBXActiveLobeWeights const &that);

    /// Assignment.
    PRMAN_INLINE RixBXActiveLobeWeights &operator= 
                                       (RixBXActiveLobeWeights const &that);

    // Get the pointer to the array of weights for a diffuse or specular lobe.
    PRMAN_INLINE RtColorRGB const *GetDiffuseLobe(int i) const;
    PRMAN_INLINE RtColorRGB const *GetSpecularLobe(int i) const;
    PRMAN_INLINE RtColorRGB *GetDiffuseLobe(int i);
    PRMAN_INLINE RtColorRGB *GetSpecularLobe(int i);

    // Clears all diffuse or specular lobes from active lobes list
    PRMAN_INLINE void ClearAllDiffuseLobes();
    PRMAN_INLINE void ClearAllSpecularLobes();

    // Get or set the current offset into array of weights.
    PRMAN_INLINE int  GetOffset() const;
    PRMAN_INLINE void SetOffset(int offset);

    // Get or set the lobe traits.
    PRMAN_INLINE RixBXLobeTraits GetLobeTraits() const;
    PRMAN_INLINE void SetLobeTraits(RixBXLobeTraits lobes);

    // Get the number of diffuse or specular lobes.
    PRMAN_INLINE unsigned char GetNumDiffuseLobes() const;
    PRMAN_INLINE unsigned char GetNumSpecularLobes() const;

    // Get the original LPE id of a diffuse or specular lobe.
    PRMAN_INLINE unsigned char GetDiffuseLpeId(int i) const;
    PRMAN_INLINE unsigned char GetSpecularLpeId(int i) const;

    // Return the sum at a particular index in the array of lobe weights.
    PRMAN_INLINE RtColorRGB SumAtIndex(int index) const;

    // Multiply by a value at a particular index in the array of lobe weights.
    PRMAN_INLINE void MultiplyByWeightAtIndex(int index, float wgt);
    PRMAN_INLINE void MultiplyByWeightAtIndex(int index, RtColorRGB const &wgt);

  private:
    friend class RixBXLobeWeights;

    // Ptrs to diffuse and specular weights
    RtColorRGB *m_diffuseLobes[k_RixBXMaxNumDiffuseLobes];
    RtColorRGB *m_specularLobes[k_RixBXMaxNumSpecularLobes]; 

    int m_offset;                     // Offset into arrays
    RixBXLobeTraits m_lobeTraits;     // Active lobe traits
    unsigned char m_numDiffuseLobes;  // Diff lobe count
    unsigned char m_numSpecularLobes; // Spec lobe count

    // Diffuse and specular LPE ids.
    unsigned char m_diffuseLpeIds[k_RixBXMaxNumDiffuseLobes];   
    unsigned char m_specularLpeIds[k_RixBXMaxNumSpecularLobes]; 
};

// RixBXLobeWeights distributes weights into qualitative properties.
struct RixBXLobeWeights
{
    /// Constructor; sets the number of diffuse and specular lobes to zero.
    PRMAN_INLINE RixBXLobeWeights();

    /// Constructor; sets all fields to the values given.
    PRMAN_INLINE RixBXLobeWeights(int numPoints, 
                                  int numDiffuseLobes,
                                  int numSpecularLobes, 
                                  RtColorRGB *diffuseLobes[], 
                                  RtColorRGB *specularLobes[],
                                  int offset = 0);

    /// Copy constructor.
    PRMAN_INLINE RixBXLobeWeights(RixBXLobeWeights const &that);

    /// Assignment.
    PRMAN_INLINE RixBXLobeWeights &operator= (RixBXLobeWeights const &that);

    // Get the pointer to the array of weights for a diffuse or specular lobe.
    PRMAN_INLINE RtColorRGB const *GetDiffuseLobe(int i) const;
    PRMAN_INLINE RtColorRGB const *GetSpecularLobe(int i) const;
    PRMAN_INLINE RtColorRGB *GetDiffuseLobe(int i);
    PRMAN_INLINE RtColorRGB *GetSpecularLobe(int i);

    // Get or set the current number of points in the arrays of weights.
    PRMAN_INLINE int  GetNumPoints() const;
    PRMAN_INLINE void SetNumPoints(int numPoints);

    // Get or set the current offset into array of weights.
    PRMAN_INLINE int  GetOffset() const;
    PRMAN_INLINE void SetOffset(int offset);

    // Get, set or add to the active lobe traits.
    PRMAN_INLINE RixBXLobeTraits GetActiveLobeTraits() const;
    PRMAN_INLINE void SetActiveLobeTraits(RixBXLobeTraits lobes);
    PRMAN_INLINE void AddActiveLobeTraits(RixBXLobeTraits lobes);

    // Get the number of diffuse or specular lobes.
    PRMAN_INLINE int GetNumDiffuseLobes() const;
    PRMAN_INLINE int GetNumSpecularLobes() const;

    /// Add a particular lobe to the set of active lobes, and also optionally 
    /// zero out all of the weights. Returns a pointer into the lobe weights.
    PRMAN_INLINE RtColorRGB *AddActiveLobe(RixBXLobeSampled lobe, 
                                           bool doInitializeWeights = true);

    /// Return just the active lobes in the provided RixBXActiveLobeWeights.
    PRMAN_INLINE void GetActiveLobes(RixBXActiveLobeWeights &r);

    /// Return the intersection of the active lobes for both this and another
    /// RixBXLobeWeights.
    PRMAN_INLINE void GetActiveLobesIntersection
                          (RixBXLobeWeights &rhs,
                           RixBXActiveLobeWeights &activeLhs,
                           RixBXActiveLobeWeights &activeRhs);

    // Copy over just the active lobe weights in 'src' at the given index into 
    // the lobe weights. Any lobes that are not present in 'src' will not be
    // updated in this instance. 
    PRMAN_INLINE void CopyWeightAtIndex(int index, 
                                        RixBXActiveLobeWeights const &src);

    // Add in just the active lobe weights in 'src' at the given index into 
    // the lobe weights. Any lobes that are not present in 'src' will not be
    // updated in this instance.
    PRMAN_INLINE void AddWeightAtIndex(int index, 
                                       RixBXActiveLobeWeights const &src);

  private:
    // Ptrs to diffuse and specular weights
    RtColorRGB *m_diffuseLobes[k_RixBXMaxNumDiffuseLobes]; 
    RtColorRGB *m_specularLobes[k_RixBXMaxNumSpecularLobes]; 

    int m_numPoints;                                    // Size of each array
    int m_offset;                                       // Offset into arrays
    RixBXLobeTraits m_activeLobeTraits;                 // Active lobe traits
    unsigned char m_numDiffuseLobes;                    // Diff lobe count
    unsigned char m_numSpecularLobes;                   // Spec lobe count
};

//
// --- inline implementations of classes above ---
//

//
// class RixBXLobeSampled inline implementation
//

PRMAN_INLINE
RixBXLobeSampled::RixBXLobeSampled()
{
    /* Init all fields to zero. We write one instruction that has the 
     * same effect as performing the following assignments:
     
     fields.bits.valid = 0;
     fields.bits.discrete = 0;
     fields.bits.specular = 0;
     fields.bits.reflect = 0;
     fields.bits.entering = 0;
     fields.bits.continuation = 0;
     fields.bits.lpeId = 0;
     fields.bits.lobeId = 0;
     fields.bits.unused = 0;
    */
    
    fields.us = 0;
}

PRMAN_INLINE 
RixBXLobeSampled::RixBXLobeSampled(unsigned short serialized)
{
    fields.us = serialized;
}

PRMAN_INLINE
RixBXLobeSampled::RixBXLobeSampled(bool discreteV, bool specularV, 
                                   bool reflectV, unsigned char lpeIdV,
                                   unsigned char lobeIdV)
{
    fields.bits.valid = 1;
    fields.bits.discrete = discreteV;
    fields.bits.specular = specularV;
    fields.bits.reflect = reflectV;
    fields.bits.entering = 0;
    fields.bits.continuation = 0;
    fields.bits.lpeId = lpeIdV;
    fields.bits.lobeId = lobeIdV;
    fields.bits.unused = 0;
}

PRMAN_INLINE 
bool RixBXLobeSampled::GetValid() const 
{
    return fields.bits.valid; 
}

PRMAN_INLINE 
bool RixBXLobeSampled::GetDiscrete() const 
{ 
    return fields.bits.valid && fields.bits.discrete; 
}

PRMAN_INLINE 
bool RixBXLobeSampled::GetSolidAngle() const 
{ 
    return fields.bits.valid && !fields.bits.discrete; 
}

PRMAN_INLINE 
bool RixBXLobeSampled::GetDiffuse() const 
{
    return fields.bits.valid && !fields.bits.specular; 
}

PRMAN_INLINE 
bool RixBXLobeSampled::GetSpecular() const 
{ 
    return fields.bits.valid && fields.bits.specular; 
}

PRMAN_INLINE 
bool RixBXLobeSampled::GetReflect() const 
{ 
    return fields.bits.valid && fields.bits.reflect; 
}

PRMAN_INLINE 
bool RixBXLobeSampled::GetTransmit(bool *enteringV) const 
{ 
    bool transmit = fields.bits.valid && !fields.bits.reflect; 
    if(enteringV)
        *enteringV = fields.bits.entering && transmit;
    return transmit;
}

PRMAN_INLINE 
bool RixBXLobeSampled::GetEntering() const 
{ 
    return fields.bits.valid && !fields.bits.reflect && fields.bits.entering;
}

PRMAN_INLINE 
bool RixBXLobeSampled::GetContinuation() const 
{ 
    return fields.bits.valid && fields.bits.continuation;
}

PRMAN_INLINE 
bool RixBXLobeSampled::GetScattering() const 
{ 
    return fields.bits.valid && !fields.bits.continuation;
}

PRMAN_INLINE 
unsigned char RixBXLobeSampled::GetLpeId() const 
{ 
    return (unsigned char) (fields.bits.valid ? fields.bits.lpeId : 0);
}

PRMAN_INLINE 
unsigned char RixBXLobeSampled::GetLobeId() const 
{ 
    return (unsigned char) (fields.bits.valid ? fields.bits.lobeId : 0);
}

PRMAN_INLINE 
void RixBXLobeSampled::SetValid(bool val) 
{ 
    fields.bits.valid = val; 
}

PRMAN_INLINE 
void RixBXLobeSampled::SetDiscrete(bool val) 
{ 
    fields.bits.discrete = val; 
}

PRMAN_INLINE 
void RixBXLobeSampled::SetSpecular(bool val) 
{
    fields.bits.specular = val; 
}

PRMAN_INLINE 
void RixBXLobeSampled::SetReflect()
{ 
    fields.bits.reflect = 1;
}

PRMAN_INLINE 
void RixBXLobeSampled::SetTransmit(bool enterval)
{ 
    fields.bits.reflect = 0;
    fields.bits.entering = enterval;
}

PRMAN_INLINE 
void RixBXLobeSampled::SetEntering(bool enterval)
{
    // valid only for Transmit
    assert(fields.bits.reflect == 0);
    fields.bits.entering = enterval;
}

PRMAN_INLINE 
void RixBXLobeSampled::SetContinuation(bool val)
{
    fields.bits.continuation = val;
}

PRMAN_INLINE 
void RixBXLobeSampled::SetLpeId(unsigned char val) 
{ 
    fields.bits.lpeId = val; 
}

PRMAN_INLINE 
void RixBXLobeSampled::SetLobeId(unsigned char val) 
{ 
    fields.bits.lobeId = val; 
}

PRMAN_INLINE 
void RixBXLobeSampled::Set(bool vDiscrete, bool vSpecular, bool vReflect,
                           bool vContinuation,
                           unsigned char vLpeId, unsigned char vLobeId)
{
    fields.bits.valid = 1;
    fields.bits.discrete = vDiscrete;
    fields.bits.specular = vSpecular;
    fields.bits.reflect = vReflect;
    fields.bits.continuation = vContinuation;
    fields.bits.entering = 0;
    fields.bits.lpeId = vLpeId;
    fields.bits.lobeId = vLobeId;
    fields.bits.unused = 0;
}

PRMAN_INLINE 
unsigned short RixBXLobeSampled::Serialize() const
{
    return fields.us;
}

// 
// RixBXLookupLobeByName() inline implementation
//

PRMAN_INLINE
RixBXLobeSampled RixBXLookupLobeByName(RixContext &ctx, 
                                       bool discrete, bool specular, 
                                       bool reflect, unsigned char lobeId, 
                                       char const *name)
{
    unsigned char lpeId = 0;
    if (RixLPEInfo *lpeInfo = (RixLPEInfo *) ctx.GetRixInterface(k_RixLPEInfo))
    {
        lpeId = (unsigned char)lpeInfo->GetLpeIdByName(discrete, specular, 
                                                       reflect, lobeId, name);
    }
    return RixBXLobeSampled(discrete, specular, reflect, lpeId, lobeId);
}

//
// class RixBXLobeTraits inline implementation.
//

PRMAN_INLINE
RixBXLobeTraits::RixBXLobeTraits()
{
    SetNone();
}

PRMAN_INLINE 
RixBXLobeTraits::RixBXLobeTraits(unsigned serialized)
{
    fields.us = serialized;
}

PRMAN_INLINE
RixBXLobeTraits::RixBXLobeTraits(bool discrete, bool reflect, bool transmit, 
                                 unsigned short D, unsigned short S) 
{
    assert(sizeof(fields.bits) == sizeof(unsigned));
    fields.bits.discreteSubset = discrete;
    fields.bits.reflectSubset = reflect;
    fields.bits.transmitSubset = transmit;
    fields.bits.continuationSubset = 0;
    fields.bits.D = D;
    fields.bits.S = S;
    fields.bits.maxspeculardepth = 0;
    fields.bits.maxdiffusedepth = 0;
    fields.bits.unused = 0;
}

PRMAN_INLINE
RixBXLobeTraits::RixBXLobeTraits(RixBXLobeSampled lobe)
{
    if (lobe.GetValid())
    {
        fields.bits.discreteSubset = lobe.GetDiscrete();
        fields.bits.reflectSubset  = lobe.GetReflect();
        fields.bits.transmitSubset = lobe.GetTransmit();
        fields.bits.continuationSubset = lobe.GetContinuation();
        
        if (lobe.GetDiffuse() && lobe.GetLpeId() < k_RixBXMaxNumDiffuseLobes)
            fields.bits.D = (unsigned short)(1 << lobe.GetLpeId());
        else
            fields.bits.D = 0;
        
        if (lobe.GetSpecular() && lobe.GetLpeId() < k_RixBXMaxNumSpecularLobes)
            fields.bits.S = (unsigned short)(1 << lobe.GetLpeId());
        else 
            fields.bits.S = 0;
    }
    else
    {
        SetNone();
    }
    fields.bits.maxspeculardepth = 0;
    fields.bits.maxdiffusedepth = 0;
}

PRMAN_INLINE
bool RixBXLobeTraits::GetDiscrete() const
{
    return fields.bits.discreteSubset;
}

PRMAN_INLINE
bool RixBXLobeTraits::GetReflect() const
{
    return fields.bits.reflectSubset;
}

PRMAN_INLINE
bool RixBXLobeTraits::GetTransmit() const
{
    return fields.bits.transmitSubset;
}

PRMAN_INLINE
bool RixBXLobeTraits::GetContinuation() const
{
    return fields.bits.continuationSubset;
}

PRMAN_INLINE
unsigned short RixBXLobeTraits::GetDiffuse() const
{
    return fields.bits.D;
}

PRMAN_INLINE
unsigned short RixBXLobeTraits::GetSpecular() const
{
    return fields.bits.S;
}

PRMAN_INLINE
bool RixBXLobeTraits::GetMaxSpecularDepth() const
{
    return fields.bits.maxspeculardepth;
}

PRMAN_INLINE
bool RixBXLobeTraits::GetMaxDiffuseDepth() const
{
    return fields.bits.maxdiffusedepth;
}

PRMAN_INLINE 
void RixBXLobeTraits::SetDiscrete(bool val)
{
    fields.bits.discreteSubset = val;
}

PRMAN_INLINE 
void RixBXLobeTraits::SetReflect(bool val)
{
    fields.bits.reflectSubset = val;
}

PRMAN_INLINE 
void RixBXLobeTraits::SetTransmit(bool val)
{
    fields.bits.transmitSubset = val;
}

PRMAN_INLINE 
void RixBXLobeTraits::SetContinuation(bool val)
{
    fields.bits.continuationSubset = val;
}

PRMAN_INLINE 
void RixBXLobeTraits::SetDiffuse(unsigned short val)
{
    fields.bits.D = val;
}

PRMAN_INLINE 
void RixBXLobeTraits::SetSpecular(unsigned short val)
{
    fields.bits.S = val;
}

PRMAN_INLINE 
void RixBXLobeTraits::SetMaxSpecularDepth(bool val)
{
    fields.bits.maxspeculardepth = val;
}

PRMAN_INLINE 
void RixBXLobeTraits::SetMaxDiffuseDepth(bool val)
{
    fields.bits.maxdiffusedepth = val;
}

PRMAN_INLINE
void RixBXLobeTraits::SetNone()
{
    /* Init all fields to zero. We write one instruction that has the 
     * same effect as performing the following assignments:
     
     fields.bits.discreteSubset = 0;
     fields.bits.reflectSubset = 0;
     fields.bits.transmitSubset = 0;
     fields.bits.continuationSubset = 0;
     fields.bits.D = 0;
     fields.bits.S = 0;
     fields.bits.maxspeculardepth = 0;
     fields.bits.maxdiffusedepth = 0;
    */
    
    fields.us = 0;
}

PRMAN_INLINE
void RixBXLobeTraits::SetAll()
{
    fields.bits.discreteSubset = 0;
    fields.bits.reflectSubset = 1;
    fields.bits.transmitSubset = 1;
    fields.bits.continuationSubset = 0;
    fields.bits.maxspeculardepth = 0;
    fields.bits.maxdiffusedepth = 0;
    fields.bits.D = 0x0F;
    fields.bits.S = 0xFF;
}

PRMAN_INLINE
bool RixBXLobeTraits::HasAny() const
{
    return ((fields.bits.D != 0) || (fields.bits.S != 0)) &&
        (fields.bits.reflectSubset || fields.bits.transmitSubset ||
         fields.bits.continuationSubset);
}

PRMAN_INLINE
bool RixBXLobeTraits::HasAnyDiffuse() const
{
    return (fields.bits.D != 0) && (fields.bits.reflectSubset || 
                                    fields.bits.transmitSubset);
}

PRMAN_INLINE
bool RixBXLobeTraits::HasAnySpecular() const
{
    return (fields.bits.S != 0) && (fields.bits.reflectSubset || 
                                    fields.bits.transmitSubset);
}

PRMAN_INLINE 
unsigned RixBXLobeTraits::Serialize() const
{
    return fields.us;
}

PRMAN_INLINE
RixBXLobeTraits const & 
RixBXLobeTraits::operator &=(RixBXLobeTraits const &rhs)
{
    /* Bitwise AND all fields. We write one instruction that has the 
     * same effect as performing the following assignments:
     
     fields.bits.discreteSubset &= rhs.fields.bits.discreteSubset;
     fields.bits.reflectSubset &= rhs.fields.bits.reflectSubset;
     fields.bits.transmitSubset &= rhs.fields.bits.transmitSubset;
     fields.bits.continuationSubset &= rhs.fields.bits.continuationSubset;
     fields.bits.D &= rhs.fields.bits.D;
     fields.bits.S &= rhs.fields.bits.S;
     fields.bits.maxspeculardepth &= rhs.fields.bits.maxspeculardepth;
     fields.bits.maxdiffusedepth  &= rhs.fields.bits.maxdiffusedepth;
    */
    
    fields.us &= rhs.fields.us;
    
    return *this;
}

PRMAN_INLINE
RixBXLobeTraits const & 
RixBXLobeTraits::operator |=(RixBXLobeTraits const &rhs)
{
    /* Bitwise OR all fields. We write one instruction that has the 
     * same effect as performing the following assignments:
     
     fields.bits.discreteSubset |= rhs.fields.bits.discreteSubset;
     fields.bits.reflectSubset |= rhs.fields.bits.reflectSubset;
     fields.bits.transmitSubset |= rhs.fields.bits.transmitSubset;
     fields.bits.continuationSubset |= rhs.fields.bits.continuationSubset;
     fields.bits.D |= rhs.fields.bits.D;
     fields.bits.S |= rhs.fields.bits.S;
     fields.bits.maxspeculardepth |= rhs.fields.bits.maxspeculardepth;
     fields.bits.maxdiffusedepth  |= rhs.fields.bits.maxdiffusedepth;
    */
    
    fields.us |= rhs.fields.us;
    
    return *this;
}

PRMAN_INLINE RixBXLobeTraits operator & (RixBXLobeTraits const &lhs, 
                                         RixBXLobeTraits const &rhs)
{
    /* Bitwise AND all fields. We write one instruction that has the 
     * same effect as performing the following assignments:
     
       r.fields.bits.discreteSubset = 
           lhs.fields.bits.discreteSubset & rhs.fields.bits.discreteSubset;
       r.fields.bits.reflectSubset = 
           lhs.fields.bits.reflectSubset & rhs.fields.bits.reflectSubset;
       r.fields.bits.transmitSubset = 
           lhs.fields.bits.transmitSubset & rhs.fields.bits.transmitSubset;
       r.fields.bits.continuationSubset = 
           lhs.fields.bits.continuationSubset & 
           rhs.fields.bits.continuationSubset;
       r.fields.bits.D = lhs.fields.bits.D & rhs.fields.bits.D;
       r.fields.bits.S = lhs.fields.bits.S & rhs.fields.bits.S;
    */
    
    RixBXLobeTraits r(lhs.Serialize() & rhs.Serialize());
    return r;
}

PRMAN_INLINE RixBXLobeTraits operator | (RixBXLobeTraits const &lhs, 
                                         RixBXLobeTraits const &rhs)
{
    /* Bitwise OR all fields. We write one instruction that has the 
     * same effect as performing the following assignments:
     
       r.fields.bits.discreteSubset = 
           lhs.fields.bits.discreteSubset | rhs.fields.bits.discreteSubset;
       r.fields.bits.reflectSubset = 
           lhs.fields.bits.reflectSubset | rhs.fields.bits.reflectSubset;
       r.fields.bits.transmitSubset = 
           lhs.fields.bits.transmitSubset | rhs.fields.bits.transmitSubset;
       r.fields.bits.continuationSubset = 
           lhs.fields.bits.continuationSubset | 
           rhs.fields.bits.continuationSubset;
       r.fields.bits.D = lhs.fields.bits.D | rhs.fields.bits.D;
       r.fields.bits.S = lhs.fields.bits.S | rhs.fields.bits.S;
    */
    
    RixBXLobeTraits r(lhs.Serialize() | rhs.Serialize());
    return r;
}

//
// class RixBXActiveLobeWeights implementation
//

PRMAN_INLINE 
RixBXActiveLobeWeights::RixBXActiveLobeWeights()
    :
    m_offset(0),
    m_numDiffuseLobes(0),
    m_numSpecularLobes(0)
{
}

PRMAN_INLINE
RixBXActiveLobeWeights::RixBXActiveLobeWeights(RixBXLobeTraits lobeTraits, 
                                               int numDiffuseLobes,
                                               int numSpecularLobes, 
                                               RtColorRGB *diffuseLobes[], 
                                               RtColorRGB *specularLobes[],
                                               unsigned char diffuseLpeIds[],
                                               unsigned char specularLpeIds[], 
                                               int offset)
    :
    m_offset(offset),
    m_lobeTraits(lobeTraits), 
    m_numDiffuseLobes((unsigned char)numDiffuseLobes),
    m_numSpecularLobes((unsigned char)numSpecularLobes)
{
    for (int i = 0; i < numDiffuseLobes; i++)
    {
        m_diffuseLobes[i] = diffuseLobes[i];
        m_diffuseLpeIds[i] = diffuseLpeIds[i];
    }
    
    for (int i = 0; i < numSpecularLobes; i++)
    {
        m_specularLobes[i] = specularLobes[i];
        m_specularLpeIds[i] = specularLpeIds[i];
    }
}

PRMAN_INLINE 
RixBXActiveLobeWeights::RixBXActiveLobeWeights
                            (RixBXActiveLobeWeights const &that)
    :
    m_offset(that.m_offset),
    m_lobeTraits(that.m_lobeTraits), 
    m_numDiffuseLobes(that.m_numDiffuseLobes),
    m_numSpecularLobes(that.m_numSpecularLobes)
{
    for (int i = 0; i < m_numDiffuseLobes; i++)
    {
        m_diffuseLobes[i] = that.m_diffuseLobes[i];
        m_diffuseLpeIds[i] = that.m_diffuseLpeIds[i];
    }
    for (int i = 0; i < m_numSpecularLobes; i++)
    {
        m_specularLobes[i] = that.m_specularLobes[i];
        m_specularLpeIds[i] = that.m_specularLpeIds[i];
    }
}

PRMAN_INLINE 
RixBXActiveLobeWeights & 
RixBXActiveLobeWeights::operator= (RixBXActiveLobeWeights const &that)
{
    m_offset = that.m_offset;
    m_lobeTraits = that.m_lobeTraits;
    m_numDiffuseLobes = that.m_numDiffuseLobes;
    m_numSpecularLobes = that.m_numSpecularLobes;
    
    for (int i = 0; i < m_numDiffuseLobes; i++)
    {
        m_diffuseLobes[i] = that.m_diffuseLobes[i];
        m_diffuseLpeIds[i] = that.m_diffuseLpeIds[i];
    }
    for (int i = 0; i < m_numSpecularLobes; i++)
    {
        m_specularLobes[i] = that.m_specularLobes[i];
        m_specularLpeIds[i] = that.m_specularLpeIds[i];
    }
    
    return *this;
}

PRMAN_INLINE
int  RixBXActiveLobeWeights::GetOffset() const 
{ 
    return m_offset; 
}

PRMAN_INLINE
void RixBXActiveLobeWeights::SetOffset(int offset) 
{ 
    m_offset = offset; 
}

PRMAN_INLINE
RixBXLobeTraits RixBXActiveLobeWeights::GetLobeTraits() const
{
    return m_lobeTraits;
}

PRMAN_INLINE
void RixBXActiveLobeWeights::SetLobeTraits(RixBXLobeTraits lobes) 
{
    m_lobeTraits = lobes;
}

PRMAN_INLINE unsigned char 
RixBXActiveLobeWeights::GetNumDiffuseLobes() const 
{
    return m_numDiffuseLobes; 
}

PRMAN_INLINE unsigned char 
RixBXActiveLobeWeights::GetNumSpecularLobes() const 
{ 
    return m_numSpecularLobes; 
}

PRMAN_INLINE RtColorRGB const *
RixBXActiveLobeWeights::GetDiffuseLobe(int i) const 
{
    return m_diffuseLobes[i] + m_offset; 
}

PRMAN_INLINE RtColorRGB const *
RixBXActiveLobeWeights::GetSpecularLobe(int i) const 
{
    return m_specularLobes[i] + m_offset; 
}

PRMAN_INLINE RtColorRGB *
RixBXActiveLobeWeights::GetDiffuseLobe(int i) 
{
    return m_diffuseLobes[i] + m_offset; 
}

PRMAN_INLINE RtColorRGB *
RixBXActiveLobeWeights::GetSpecularLobe(int i) 
{
    return m_specularLobes[i] + m_offset; 
}

PRMAN_INLINE unsigned char 
RixBXActiveLobeWeights::GetDiffuseLpeId(int i) const 
{
    return m_diffuseLpeIds[i];
}

PRMAN_INLINE unsigned char 
RixBXActiveLobeWeights::GetSpecularLpeId(int i) const 
{
    return m_specularLpeIds[i];
}

PRMAN_INLINE void 
RixBXActiveLobeWeights::ClearAllDiffuseLobes() 
{
    m_numDiffuseLobes = 0;
    // Removes all diffuse lobes from traits
    m_lobeTraits &= k_RixBXTraitsAllSpecular; 
}

PRMAN_INLINE void 
RixBXActiveLobeWeights::ClearAllSpecularLobes()
{
    m_numSpecularLobes = 0;
    // Removes all specular lobes from traits
    m_lobeTraits &= k_RixBXTraitsAllDiffuse; 
}

PRMAN_INLINE 
RtColorRGB RixBXActiveLobeWeights::SumAtIndex(int index) const
{
    RtColorRGB sum(0.0f);

    int idx = m_offset + index;
    for (int i = 0; i < m_numDiffuseLobes; i++)
        sum += m_diffuseLobes[i][idx];
    for (int i = 0; i < m_numSpecularLobes; i++)
        sum += m_specularLobes[i][idx];
    
    return sum;
}

PRMAN_INLINE
void RixBXActiveLobeWeights::MultiplyByWeightAtIndex
         (int index, float weight)
{
    int idx = m_offset + index;
    for (int i = 0; i < m_numDiffuseLobes; i++)
        m_diffuseLobes[i][idx] *= weight;
    for (int i = 0; i < m_numSpecularLobes; i++)
        m_specularLobes[i][idx] *= weight;
}

PRMAN_INLINE
void RixBXActiveLobeWeights::MultiplyByWeightAtIndex
         (int index, RtColorRGB const &weight)
{
    int idx = m_offset + index;
    for (int i = 0; i < m_numDiffuseLobes; i++)
        m_diffuseLobes[i][idx] *= weight;
    for (int i = 0; i < m_numSpecularLobes; i++)
        m_specularLobes[i][idx] *= weight;
}

//
// class RixBXLobeWeights implementation
//

PRMAN_INLINE
RixBXLobeWeights::RixBXLobeWeights()
    :
    m_numPoints(0), 
    m_offset(0),
    m_numDiffuseLobes(0),
    m_numSpecularLobes(0)
{
}

PRMAN_INLINE
RixBXLobeWeights::RixBXLobeWeights(int numPoints, 
                                   int numDiffuseLobes,
                                   int numSpecularLobes, 
                                   RtColorRGB *diffuseLobes[], 
                                   RtColorRGB *specularLobes[],
                                   int offset)
    :
    m_numPoints(numPoints), 
    m_offset(offset),
    m_numDiffuseLobes((unsigned char)numDiffuseLobes),
    m_numSpecularLobes((unsigned char)numSpecularLobes)
{
    for (int i = 0; i < numDiffuseLobes; i++)
        m_diffuseLobes[i] = diffuseLobes[i];
    
    for (int i = 0; i < numSpecularLobes; i++)
        m_specularLobes[i] = specularLobes[i];
}

PRMAN_INLINE 
RixBXLobeWeights::RixBXLobeWeights(RixBXLobeWeights const &that)
    :
    m_numPoints(that.m_numPoints),
    m_offset(that.m_offset),
    m_activeLobeTraits(that.m_activeLobeTraits),
    m_numDiffuseLobes(that.m_numDiffuseLobes),
    m_numSpecularLobes(that.m_numSpecularLobes)
{
    for (int i = 0; i < m_numDiffuseLobes; i++)
        m_diffuseLobes[i] = that.m_diffuseLobes[i];
    
    for (int i = 0; i < m_numSpecularLobes; i++)
        m_specularLobes[i] = that.m_specularLobes[i];
}

PRMAN_INLINE 
RixBXLobeWeights & 
RixBXLobeWeights::operator= (RixBXLobeWeights const &that)
{
    m_numPoints = that.m_numPoints;
    m_offset = that.m_offset;
    m_activeLobeTraits = that.m_activeLobeTraits;
    m_numDiffuseLobes = that.m_numDiffuseLobes;
    m_numSpecularLobes = that.m_numSpecularLobes;
    
    for (int i = 0; i < m_numDiffuseLobes; i++)
        m_diffuseLobes[i] = that.m_diffuseLobes[i];

    for (int i = 0; i < m_numSpecularLobes; i++)
        m_specularLobes[i] = that.m_specularLobes[i];
    
    return *this;
}

PRMAN_INLINE RtColorRGB const *
RixBXLobeWeights::GetDiffuseLobe(int i) const 
{
    return m_diffuseLobes[i] + m_offset; 
}

PRMAN_INLINE RtColorRGB const *
RixBXLobeWeights::GetSpecularLobe(int i) const 
{
    return m_specularLobes[i] + m_offset; 
}

PRMAN_INLINE RtColorRGB *
RixBXLobeWeights::GetDiffuseLobe(int i) 
{
    return m_diffuseLobes[i] + m_offset; 
}

PRMAN_INLINE RtColorRGB *
RixBXLobeWeights::GetSpecularLobe(int i) 
{
    return m_specularLobes[i] + m_offset; 
}

PRMAN_INLINE
int  RixBXLobeWeights::GetNumPoints() const { return m_numPoints; }

PRMAN_INLINE
void RixBXLobeWeights::SetNumPoints(int numPoints) { m_numPoints = numPoints; }

PRMAN_INLINE
int  RixBXLobeWeights::GetOffset() const { return m_offset; }

PRMAN_INLINE
void RixBXLobeWeights::SetOffset(int offset) { m_offset = offset; }

PRMAN_INLINE 
RixBXLobeTraits RixBXLobeWeights::GetActiveLobeTraits() const 
{
    return m_activeLobeTraits;
}

PRMAN_INLINE 
void RixBXLobeWeights::SetActiveLobeTraits(RixBXLobeTraits lobes)
{
    m_activeLobeTraits = lobes;
}

PRMAN_INLINE
void RixBXLobeWeights::AddActiveLobeTraits(RixBXLobeTraits lobes) 
{
    m_activeLobeTraits |= lobes;
}

PRMAN_INLINE 
int RixBXLobeWeights::GetNumDiffuseLobes() const 
{ 
    return m_numDiffuseLobes; 
}

PRMAN_INLINE 
int RixBXLobeWeights::GetNumSpecularLobes() const 
{ 
    return m_numSpecularLobes; 
}

PRMAN_INLINE 
RtColorRGB *RixBXLobeWeights::AddActiveLobe(RixBXLobeSampled lobeSampled, 
                                            bool doInitializeWeights)
{
    if (lobeSampled.GetDiffuse())
    {
        RixBXLobeTraits traits(lobeSampled);
        RtColorRGB *p = m_diffuseLobes[lobeSampled.GetLpeId()];
        if (!(m_activeLobeTraits.GetDiffuse() & traits.GetDiffuse()))
        {
            m_activeLobeTraits |= traits;
            if (doInitializeWeights)
                memset(p, 0, m_numPoints * sizeof(RtColorRGB));
        }
        return p + m_offset;
    }
    else if (lobeSampled.GetSpecular())
    {
        RixBXLobeTraits traits(lobeSampled);
        RtColorRGB *p = m_specularLobes[lobeSampled.GetLpeId()];
        if (!(m_activeLobeTraits.GetSpecular() & traits.GetSpecular()))
        {
            m_activeLobeTraits |= traits;
            if (doInitializeWeights)
                memset(p, 0, m_numPoints * sizeof(RtColorRGB));
        }
        return p + m_offset;
    }
    else
        return NULL;
}

PRMAN_INLINE
void RixBXLobeWeights::GetActiveLobes(RixBXActiveLobeWeights &r)
{
    r.m_numDiffuseLobes = r.m_numSpecularLobes = 0;
    r.m_lobeTraits = m_activeLobeTraits;
    r.m_offset = m_offset;
    
    RixBXLobeTraits lobes = m_activeLobeTraits;
    
    int ndiff = m_numDiffuseLobes;
    for (int lpeId = 0, bit = 1; lpeId < ndiff; lpeId++, bit <<= 1)
    {
        if (lobes.GetDiffuse() & bit)
        {
            r.m_diffuseLobes[r.m_numDiffuseLobes] = m_diffuseLobes[lpeId];
            r.m_diffuseLpeIds[r.m_numDiffuseLobes] = (unsigned char)lpeId;
            r.m_numDiffuseLobes++;
        }
    }
    int nspec = m_numSpecularLobes;
    for (int lpeId = 0, bit = 1; lpeId < nspec; lpeId++, bit <<= 1)
    {
        if (lobes.GetSpecular() & bit)
        {
            r.m_specularLobes[r.m_numSpecularLobes] = 
                m_specularLobes[lpeId];
            r.m_specularLpeIds[r.m_numSpecularLobes] = (unsigned char)lpeId;
            r.m_numSpecularLobes++;
        }
    }
}

PRMAN_INLINE
void RixBXLobeWeights::GetActiveLobesIntersection
                           (RixBXLobeWeights &rhs,
                            RixBXActiveLobeWeights &activeLhs,
                            RixBXActiveLobeWeights &activeRhs)
{
    int numDiffuseLobes = 0;
    int numSpecularLobes = 0;
    
    RixBXLobeTraits lobes = (m_activeLobeTraits & rhs.m_activeLobeTraits);
    
    int ndiff = std::min(m_numDiffuseLobes, rhs.m_numDiffuseLobes);
    for (int lpeId = 0, bit = 1; lpeId < ndiff; lpeId++, bit <<= 1)
    {
        if (lobes.GetDiffuse() & bit)
        {
            activeLhs.m_diffuseLobes[numDiffuseLobes] = 
                m_diffuseLobes[lpeId];
            activeRhs.m_diffuseLobes[numDiffuseLobes] = 
                rhs.m_diffuseLobes[lpeId];
            activeLhs.m_diffuseLpeIds[numDiffuseLobes] = (unsigned char)lpeId;
            activeRhs.m_diffuseLpeIds[numDiffuseLobes] = (unsigned char)lpeId;
            numDiffuseLobes++;
        }
    }
    int nspec = std::min(m_numSpecularLobes, rhs.m_numSpecularLobes);
    for (int lpeId = 0, bit = 1; lpeId < nspec; lpeId++, bit <<= 1)
    {
        if (lobes.GetSpecular() & bit)
        {
            activeLhs.m_specularLobes[numSpecularLobes] = 
                m_specularLobes[lpeId];
            activeRhs.m_specularLobes[numSpecularLobes] = 
                rhs.m_specularLobes[lpeId];
            activeLhs.m_specularLpeIds[numSpecularLobes] = (unsigned char)lpeId;
            activeRhs.m_specularLpeIds[numSpecularLobes] = (unsigned char)lpeId;
            numSpecularLobes++;
        }
    }
    
    activeLhs.m_offset = m_offset;
    activeLhs.m_lobeTraits = lobes;
    activeLhs.m_numDiffuseLobes = (unsigned char)numDiffuseLobes;
    activeLhs.m_numSpecularLobes = (unsigned char)numSpecularLobes;
    
    activeRhs.m_offset = rhs.m_offset;
    activeRhs.m_lobeTraits = lobes;
    activeRhs.m_numDiffuseLobes = (unsigned char)numDiffuseLobes;
    activeRhs.m_numSpecularLobes = (unsigned char)numSpecularLobes;
}

PRMAN_INLINE 
void RixBXLobeWeights::CopyWeightAtIndex(int index, 
                                         RixBXActiveLobeWeights const &src)
{
    // Copy over just the active diffuse and specular lobes in 'src'.
    int ndiff = src.GetNumDiffuseLobes();
    for (int i = 0; i < ndiff; i++)
    {
        int lpeId = src.GetDiffuseLpeId(i);
        GetDiffuseLobe(lpeId)[index] = src.GetDiffuseLobe(i)[index];
    }

    int nspec = src.GetNumSpecularLobes();
    for (int i = 0; i < nspec; i++)
    {
        int lpeId = src.GetSpecularLpeId(i);
        GetSpecularLobe(lpeId)[index] = src.GetSpecularLobe(i)[index];
    }
}

PRMAN_INLINE 
void RixBXLobeWeights::AddWeightAtIndex(int index, 
                                        RixBXActiveLobeWeights const &src)
{
    // Add in just the active diffuse and specular lobes in 'src'.
    int ndiff = src.GetNumDiffuseLobes();
    for (int i = 0; i < ndiff; i++)
    {
        int lpeId = src.GetDiffuseLpeId(i);
        GetDiffuseLobe(lpeId)[index] += src.GetDiffuseLobe(i)[index];
    }

    int nspec = src.GetNumSpecularLobes();
    for (int i = 0; i < nspec; i++)
    {
        int lpeId = src.GetSpecularLpeId(i);
        GetSpecularLobe(lpeId)[index] += src.GetSpecularLobe(i)[index];
    }
}

#endif
