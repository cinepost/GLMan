#ifndef RixShading_h
#define RixShading_h
/* $Revision: #44 $ $Date: 2015/03/11 $ */
/*
# ------------------------------------------------------------------------------
#
# Copyright (c) 2011-2015 Pixar Animation Studios. All rights reserved.
#
# The information in this file (the "Software") is provided for the
# exclusive use of the software licensees of Pixar.  Licensees have
# the right to incorporate the Software into other products for use
# by other authorized software licensees of Pixar, without fee.
# Except as expressly permitted herein, the Software may not be
# disclosed to third parties, copied or duplicated in any form, in
# whole or in part, without the prior written permission of
# Pixar Animation Studios.
#
# The copyright notices in the Software and this entire statement,
# including the above license grant, this restriction and the
# following disclaimer, must be included in all copies of the
# Software, in whole or in part, and all permitted derivative works of
# the Software, unless such copies or derivative works are solely
# in the form of machine-executable object code generated by a
# source language processor.
#
# PIXAR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
# ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT
# SHALL PIXAR BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES
# OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
# WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
# ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
# SOFTWARE.
#
# Pixar
# 1200 Park Ave
# Emeryville CA 94608
#
# ------------------------------------------------------------------------------
*/

/**
    \mainpage Rix Shading Extensions API Reference
    \brief Rix Shading Extensions are RenderMan interface extensions that
    characterize requirements of a RenderMan renderer from shading plugins.

    Rix Shading Extensions differ from RslPlugins in their execution
    model. Rix Shading Externsion are independent of RenderMan Shading Language
    (RSL) while RSLPlugins characterize plugin extensions to RSL.

    RixShadingExtensions also differ from standard RixInterfaces.
    RixShadingInterfaces are plugins defined and created external to
    the renderer, while RixInterfaces characterize services of the
    renderer and are therefore not subclassed.

    Interfaces presented here that don't subclass RixShadingPlugin
    are renderer services (RixInterfaces) but their version management
    is covariant with the ShadingPlugin interface.

    The central class defined in this file is RixShadingContext.

**/

#include "RixInterfaces.h"
#include <cassert>
#include <cstring>   // for memcpy
#include <algorithm> // for std::fill_n

#define k_RixShadingVersion 103  // XYY  (X: MAJOR, Y:MINOR)

class RixBxdfFactory;
class RixBsdf;
class RixOpacity;
class RixVolumeIntegrator;
class RixDisplayServices;
class RixParameterList;
struct RixSCParamInfo;
struct RtRayGeometry;
struct RtHitPoint;
struct RixBXLobeTraits;

/**
    RixShadingInterface enumerates the known ShadingPlugin types.
 **/
enum RixShadingInterface
{
    k_RixInvalid=0,
    k_RixPattern,
    k_RixBxdfFactory,
    k_RixIntegrator,
    k_RixProjection
};

/**
  RixSCSyncMsgs - are the possible states delivered through 
  Synchronize methods.
 **/
enum RixSCSyncMsg
{
    // delivered in primary thread...
    k_RixSCRenderBegin,
    k_RixSCRenderEnd,
    k_RixSCInstanceEdit,
    k_RixSCCancel,
    // delivered by one (arbitrary) thread...
    k_RixSCIncrementBarrier     // Only sent if wantsIncrementBarrier is true.
                                // Indicates "int increment" about to begin.
};

/**
   The RixShadingPlugin interface is the base class for Bxdf, Pattern
   and Integrator plugins.
 **/
class RixShadingPlugin
{
public:
    virtual int GetVersion() const { return m_version; }
    virtual int GetInterface() const { return k_RixInvalid; }
    virtual int Init(RixContext &ctx, char const *pluginPath) = 0;
    virtual RixSCParamInfo const *GetParamTable() = 0;
    virtual void Finalize(RixContext &ctx) = 0;

    // Synchronize: delivers occasional status information
    // from the renderer. Parameterlist contents depend upon the SyncMsg.
    // This method is optional and the default implementation ignores all 
    // events.
    virtual void Synchronize(RixContext &ctx, RixSCSyncMsg syncMsg,
                             RixParameterList const *parameterList)
    {
    }

    // CreateInstanceData:
    //  the renderer offers the service to plugins to track
    //  custom data with every instance of the plugin reference. 
    //  This is useful primarily to plugin types like Bxdf and Pattern
    //  that expect multiple instances. Instance data is usually a 
    //  function of the instance parameters and plugins that operate 
    //  in performance sensitive conditions may "bake" an understanding 
    //  of their behavior/requirements into custom representation for 
    //  tracking with the instance. The instance data can be recovered 
    //  from the operating context associated with the plugin type or
    //  via a parameter to certain methods.
    //
    //  The default implementation produces no instance data.
    //  Plugins should consider the number of potential instances
    //  that may be produced in a worst-case render to assess the
    //  memory impact of the instance data.  The renderer will free
    //  data via freefunc when it understands that the plugin instance 
    //  will no longer be needed.  During rerendering, the Create method
    //  may be invoked repeatedly within the same rendering session.
    //  The handle parameter is the value associated with the Ri instance
    //  but may not be guaranteed to be globally unique. The instanceid
    //  parameter is optionally delivered via the parameterlist 
    //  (see RI_INSTANCEID docs) and is expected (though not guaranteed)
    //  to be unique.
    struct InstanceData
    {
        InstanceData() : data(NULL), datalen(0), freefunc(NULL) {}
        RtPointer data;
        size_t datalen;
        void (*freefunc)(RtPointer);
    };
    virtual int CreateInstanceData(RixContext &,
                                   char const *handle,
                                   RixParameterList const *,
                                   InstanceData *result)
    {
        return -1; // 0 is success
    }


protected:
    RixShadingPlugin(int version) : m_version(version) {}
    virtual ~RixShadingPlugin() {}
    int m_version;
};

/**
    RixSCType enumerates the valid atomic datatypes
 **/
enum RixSCType
{
    k_RixSCInvalidType=0, 
    k_RixSCAnyType, // signals a dynamic binding scenario
    k_RixSCInteger,
    k_RixSCFloat,
    k_RixSCFloat2,
    k_RixSCFloat3,
    k_RixSCColor,
    k_RixSCPoint,
    k_RixSCVector,
    k_RixSCNormal,
    k_RixSCMatrix,
    k_RixSCString,
    k_RixSCBxdf,        // always uniform
    k_RixSCStructBegin, // always uniform
    k_RixSCStructEnd    // always uniform
};

/**
    RixSCDetail enumerates the valid sizing qualifiers
    for SC parameters.
 **/
enum RixSCDetail
{
    k_RixSCInvalidDetail=0,
    k_RixSCUniform,     // needs an eval per shading "grid"
    k_RixSCVarying,     // needs an eval per shading point
    k_RixSCAnyDetail
};

/**
    RixSCAccess characterizes parameters as input or output.
 **/
enum RixSCAccess
{
    k_RixSCInput=0,
    k_RixSCOutput,
    k_RixSCInvalidAccess
};

/**
    RixSCVolumeSelector identifies a volume region relative
    to an incident rays.
 **/
enum RixSCVolumeSelector
{
    k_RixSCAnyVolume,
    k_RixSCIncidentVolume,
    k_RixSCOppositeVolume
};

/**
    RixSCConnectionInfo identifies the origin of values associated
    with parameters evaluated through RixShadingContext.
 **/
enum RixSCConnectionInfo
{
    k_RixSCDefaultValue = 0,
    k_RixSCParameterListValue,
    k_RixSCNetworkValue
};

/**
    RixSCParamInfo captures the characteristics of an individual ScParam
**/
struct RixSCParamInfo
{
    // most common constructor of POD parameters.
    RixSCParamInfo(char const *nm, RixSCType t, 
                   RixSCAccess a = k_RixSCInput, 
                   int len = -1) :
        name(nm),
        customtype(NULL),
        type(t),
        access(a),
        arraylen(len)
    {
    }

    // full constructor
    RixSCParamInfo(char const *structnm, char const *nm, 
                  RixSCType t, RixSCAccess a = k_RixSCInput, 
                  int len = -1) :
        name(nm),
        customtype(structnm),
        type(t),
        access(a),
        arraylen(len)
    {
    }

    // default constructor, useful to signal end of paraminfo table
    RixSCParamInfo() :
        name(NULL),
        customtype(NULL),
        type(k_RixSCInvalidType),
        access(k_RixSCInvalidAccess),
        arraylen(-1)
    {
    }

    char const *name;
    char const *customtype; // NULL unless struct
    RixSCType type;
    RixSCAccess access;
    int arraylen; // -1 means no array, 0 means empty
    bool IsArray() const { return (arraylen != -1); }
};

// RixSCShadingMode conveys the current operating mode associated
// with the shading context. Associated with a mode is s shader
// whose type may depend upon it. Knowledge of the shading mode  
// allows a BxdfFactory to minimize the construction costs of
// the particular query. For example, a stained-glass material may be
// trivially opaque to presence queries but colored for Transmission
// queries. See comments for each Begin method for more details.
enum RixSCShadingMode
{
    k_RixSCInvalidShadingMode,
    k_RixSCPresenceQuery, // a BeginOpacity mode
    k_RixSCOpacityQuery, // a BeginOpacity mode
    k_RixSCScatterQuery, // a BeginScatter and BeginInterior mode
    k_RixSCVolumeTransmissionQuery, // a BeginInterior mode
    k_RixSCVolumeScatterQuery, // a BeginInterior mode, distinguishes
                               // surface-oriented scattering from volumetric
                               // scattering.
    k_RixSCPatternQuery // as for RSL networks
};

// RixParameterList exposes the non-varying values that are associated
// with the definition or editing of a shading plugin instance.  
// Parameters arrive via the RenderMan Interface and can be queried
// through this interface. Values that aren't provided in the parameterlist
// cannot be queried as the plugin is expected to know its default values.
class RixParameterList
{
public:
    virtual RtInt GetNumParams() const = 0;

    /// GetParamId maps a string name to a more efficient integer reference.
    /// The resulting paramid may be negative to support dynamic inputs.  
    /// Non-negative values are indices into the plugin's parameter table, 
    /// while negative values are interpretted as indices into the 
    /// parameterlist of a RIB instance. Returns 0 on success, returns 
    /// nonzero if named parameter is not found.
    virtual RtInt GetParamId(char const *name, RtInt *paramid) const = 0; 

    /// This version of GetParamId maps the parameterlist index (between
    /// 0 and GetNumParams()) to a paramId and described above. May be 
    /// useful when interating over the contents of a parameterlist.
    virtual RtInt GetParamId(int plistIndex, RtInt *paramid) const = 0; 

    /// GetParamInfo returns additional details about a parameter.
    /// Usually paramid is the index into caller's parameter table.
    /// In circumstances where plugin accepts dynamic parameters,
    /// the paramid should be obtained via calls to GetParamId.
    virtual RtInt GetParamInfo(RtInt paramid, RixSCType *type,
                              RixSCConnectionInfo *cinfo, 
                              int *arraylength=NULL) const = 0;

    /// This version of GetParamInfo is a convenience for use-cases
    /// where a bool notion of connection is sufficient.
    RtInt GetParamInfo(RtInt paramid, RixSCType *type,
                      bool *isconnected, int *arraylength=NULL) const
    {
        RixSCConnectionInfo cinfo;
        int err = GetParamInfo(paramid, type, &cinfo, arraylength);
        if(isconnected)
            *isconnected = (cinfo == k_RixSCNetworkValue);
        return err;
    }

    /// EvalParam fills the provided result with the value of the parameter.
    /// See GetParamId() for discussion on the nature of paramid.
    /// Since all results values are scalar we copy out by value.
    /// Caller owns and can overwrite/reuse result.
    ///
    /// k_RixSCInvalidDetail is returned if:
    ///    - the parameters isn't present in the RIB stream
    ///    - types don't match or can't be coerced
    ///    - parameter is "networked".. Since varying values aren't supported 
    ///      by this interface no default fill value is passed in. 
    virtual RixSCDetail EvalParam(RtInt paramid, RtInt arrayindex,
                                  RtInt * result) const = 0;
    virtual RixSCDetail EvalParam(RtInt paramid, RtInt arrayindex, 
                                  RtFloat * result) const = 0;
    virtual RixSCDetail EvalParam(RtInt paramid, RtInt arrayindex,
                                  RtColorRGB * result) const = 0;
    virtual RixSCDetail EvalParam(RtInt paramid, RtInt arrayindex,
                                  RtFloat3 * result) const = 0;
    virtual RixSCDetail EvalParam(RtInt paramid, RtInt arrayindex,
                                  RtMatrix4x4 * result) const = 0;
    virtual RixSCDetail EvalParam(RtInt paramid, RtInt arrayindex, 
                                  RtConstString * result) const = 0;
protected:
    virtual ~RixParameterList() {}
};

///
/// RixShadingContext is analogous to a RenderMan grid -
/// it is a group of 1 or more points that may be shaded.
/// The group of points usually arrive through ray traced "hits".
/// In this case, the shading context provides geometric details 
/// through its GetPrimVar and GetBuiltinVar methods.  
/// Associated with each primvar is a varying filter size that is 
/// computed as a function of rendering conditions such as shading rate
/// and ray differentials.  The incoming positions are not guaranteed
/// to be neighbors and so do not support requirements for computing 
/// first-differences. Rather, differential information is embodied 
/// through filter radii and these are only computable for known 
/// builtin and primitive variables. 
///
/// ShadingContexts can also be produced by ray traced "misses".  
/// Now only the ray origination information is available and the class of
/// shading activities is limited to cases where no bxdf, builtin
/// and primitive variables are required.  RixShadingContexts are 
/// comprised exclusively of hits or misses and optionally delivered 
/// across the RixIntegratorCtx's GetNearestHits method. 
///
/// ShadingContexts operate in a small number of modes according
/// to the integration requirements.
///
class RixShadingContext : public RixContext
{
public:
    /// shadingCtxId is a unique identifier for this shading context. Must 
    /// be assigned to outgoing rays (RtRayGeometry) by integrators.
    /// RtRayGeometry can use this structure to convey the launching
    /// shading context through the ray tracing system.  When a
    /// RtRayGeometry does not arise from a shading context, the Id
    /// is invalid.
    struct Id
    {
        void Invalidate() { shadingCtxNum = -6666; }
        bool IsValid() const { return shadingCtxNum != -6666; }
        short integratorCtxNum;
        short shadingCtxNum;
    } shadingCtxId; 

    /// numPts is the number of shading points. All other non-uniform
    /// values can be assumed to have this length.
    RtInt numPts;  

    /// shadingCtxTraits conveys a variety of (uniform) ShadingContex
    /// traits to shader and integrator.
    struct 
    {
        unsigned eyePath : 1;    /// true if shading for an eye path
        unsigned lightPath : 1;  /// true if shading for a light path
        unsigned primaryHit : 1; /// true if shading for a first hit 
        unsigned missContext : 1;/// true if this context represents misses
        unsigned reyesGrid : 1 ; /// true if we're operating on a reyes grid
                                 /// this may occur in a variety of caching
                                 /// conditions

        /// shadingMode contains the current mode of operation associated
        /// with this shading context.
        RixSCShadingMode shadingMode;
        union
        {
            /// The bsdf shader is non-NULL for radiance queries and is
            /// responsible for computing light scattering.
            RixBsdf *bsdf; 

            // The opacity shader is non-NULL when computing presence and
            // transmission.
            RixOpacity *opacity;
        } shader;

        // The volume shader is non-NULL when invoking volume integrators.
        RixVolumeIntegrator *volume;
        
    } scTraits; // "uniform" traits associated with the shading context

    bool HasHits() const { return (scTraits.missContext == 0); }
    bool HasMisses() const { return (scTraits.missContext == 1); }

    RixBsdf *GetBsdf() const
    {
        assert(scTraits.shadingMode == k_RixSCScatterQuery ||
               scTraits.shadingMode == k_RixSCVolumeScatterQuery);
        return scTraits.shader.bsdf;
    }

    RixOpacity *GetOpacity() const
    {
        assert(scTraits.shadingMode == k_RixSCOpacityQuery || 
               scTraits.shadingMode == k_RixSCPresenceQuery ||
               scTraits.shadingMode == k_RixSCVolumeTransmissionQuery);
        return scTraits.shader.opacity;
    }

    RixVolumeIntegrator *GetVolume() const
    {
        assert(scTraits.shadingMode == k_RixSCScatterQuery || 
               scTraits.shadingMode == k_RixSCVolumeScatterQuery ||
               scTraits.shadingMode == k_RixSCVolumeTransmissionQuery);
        return scTraits.volume;
    }

    /// Support for volume integration:
    ///
    ///  Begin/EndVolume: can be called by primary integrators to 
    ///  acquire a volume integrator for the selected volume subset 
    ///  (incident or opposite). Depending on the ray path and the
    ///  requirements of the volume integrator itself,  the resulting 
    ///  volume integrator may be bound to a different shading context 
    ///  that was associated with the originating rays.  For this
    ///  reason the incoming ray geometries must be non-const, their
    ///  shadingCtxIndex may change.
    virtual bool HasVolume(RixSCVolumeSelector) const = 0;
    virtual RixVolumeIntegrator *BeginVolume(RixSCVolumeSelector, 
                           RtInt nrays, RtRayGeometry *rays) const = 0;
    virtual void EndVolume(RixVolumeIntegrator *) const = 0;
    /// two convenience methods
    RixVolumeIntegrator *BeginIncidentVol(RtInt nrays, 
                                         RtRayGeometry *rays) const
    {
        return BeginVolume(k_RixSCIncidentVolume, nrays, rays);
    }
    RixVolumeIntegrator *BeginOppositeVol(RtInt nrays,
                                         RtRayGeometry *rays) const
    {
        return BeginVolume(k_RixSCOppositeVolume, nrays, rays);
    }

    ///
    ///  Begin/EndVolumeSampling: can be called by a volume integrator
    ///  to obtain a mutable shading context for the purposes of
    ///  sampling its volume region. The resulting shading context
    ///  has the same size as its creator context. Two options
    ///  for cleanup are offered.  If the volume integrator wishes
    ///  to expose/publicize a new shading context to the primary
    ///  integrator, it should set exposeVol to a non-NULL 
    ///  RixBXLobeTraits pointer (which usually points to the same
    ///  RixBXLobeTraits passed to the interior's GetNearestHits
    ///  method). The optional membership array can be used to
    ///  communicate the subset of points on the current shading
    ///  context that should be conveyed to the new one.  A non-zero
    ///  value signals the membership request in a new context. If
    ///  NULL, all points will be used to construct a new shading
    ///  context. In this usage, the return result will be a distinct
    ///  shading context appropriate for use by the primary
    ///  integrator. If exposeVol is NULL, the the result is NULL and
    ///  internal volume sampling state is released.
    virtual RixShadingContext *BeginVolumeSampling() const = 0;
    virtual RixShadingContext const *EndVolumeSampling(RixShadingContext *, 
                                      RixBXLobeTraits const *exposeVol=NULL,
                                      RtInt const *membership=NULL) const = 0;
    ///
    /// BuiltinVolumes are "preloaded" and initialized by the renderer.
    /// Plugin volumes are usually "compiled-in" to the associated Bxdf.
    /// In both cases, the Bxdf's BeginInterior method is invoked to
    /// instantiate a VolumeIntegrator object.
    enum BuiltinVolume
    {
        k_SSDiffusion // beam diffusion
    };
    virtual RixVolumeIntegrator *GetBuiltinVolume(BuiltinVolume,
                                                 RixBxdfFactory *) const = 0;

    /// integratorCtxIndex maps indices to varying ShadingContext
    /// entries to the index associated with IntegratorContext.
    /// The ith element of our integratorCtxIndex tells us the index
    /// of the associated primaryRay and other subsidiary channels.
    /// The integratorCtxIndex is critical for proper integrator
    /// functionality and should be considered "opaque" to the Bxdf.
    RtInt *integratorCtxIndex;

    /// rayId is similar to integratorCtxIndex. This array can
    /// be used by integrators to track a correspondence between the
    /// ShadingContext entries and integrator-specific data
    /// structures.  The rayId may be critical for proper functionality 
    /// of a given integrator and should be considered "opaque" to the Bxdf.
    RtInt *rayId;

    /// transmission is a per-point transmission that is associated
    /// with the ray that produced the associated hit. It's used by
    /// interiors and volumes to "occlude" the results of the 
    /// radiance computation of each point.
    RtColorRGB *transmission; 

    /// BuiltinBsdfs can be constructed cheaply and offer a basic
    /// set of capabilities. They differ from Bxdf plugins in that
    /// they expose no parameters and thus no BxdfFactories are required.
    enum BuiltinBsdf
    {
        k_NullBsdf
    };
    virtual RixBsdf *GetBuiltinBsdf(BuiltinBsdf, RixBxdfFactory *) const = 0;

    /// Get access to the display services.  This is the same display
    /// service normally offered by the integrator context but is provided
    /// here to allow RixPatterns and RixBXDFs to bypass the integrator and
    /// write directly into AOV channels for special effects.
    virtual RixDisplayServices *GetDisplayServices(int version = 1) const = 0;

    enum BuiltinVar
    {
        k_P=0,
        k_PRadius,
        k_Po,     // undisplaced P
        k_Nn,     // normalized shading normal
        k_Ngn,    // normalized geometric normal
        k_Non,    // undisplaced N
        k_Tn,     // normalized shading tangent
        k_Vn,     // normalized view vector, points away from shading points
        k_VLen,   // length of V: from the P to previous P
        k_curvature, // local surface curvature
        k_incidentRaySpread, // spread of incident ray
        k_incidentRayRadius, // radius of incident ray at hit pt
        k_incidentLobeSampled, // RixBXLobeSampled of incident rays (as RtInt)
        k_mpSize, // size of micropoly that ray hit (0 for non-tessel. surfaces)
        k_biasR, // bias to apply for rays leaving the surface
        k_biasT, // bias to apply for rays passing through the surface
        k_u,
        k_v,
        k_w,
        k_du, k_dufp = k_du, // k_dufp is an alias for k_du (fp: ray footprint)
        k_dv, k_dvfp = k_dv,
        k_dw, k_dwfp = k_dw,
        k_dPdu,
        k_dPdv,
        k_dPdw,
        k_dPdtime, 
        k_time,
        k_Id,   // the RtInt assigned via Attribute "identifier" "id"
        k_outsideIOR,
        k_Oi,
        k_numBuiltinVars
    };
    virtual void GetBuiltinVar(BuiltinVar, RtInt const**var) const = 0;
    virtual void GetBuiltinVar(BuiltinVar, RtFloat const**var) const = 0;
    virtual void GetBuiltinVar(BuiltinVar, RtFloat3 const**var) const = 0;

    /// Useful for perturbing a context for things such as bump mapping.
    /// (eg. jittering u,v,w within the du,dv,dw neighborhood).
    virtual void SetBuiltinVar(BuiltinVar, RtFloat *var) = 0;
    virtual void SetBuiltinVar(BuiltinVar, RtFloat3 *var) = 0;

    /// GetPrimVar: lazily evaluates the named primitive variable.
    /// Caller is expected to know the datatype in advance
    /// and invoke the correct variant. The optional radius parameter
    /// is filled with an approximate isotropic filter radius associated 
    /// with the projected ray differentials of each shading point.  If
    /// the primvar cannot be found, the return value is initialized
    /// with the fill value and the return value is k_RixSCInvalidDetail
    virtual RixSCDetail GetPrimVar(char const *name, RtFloat fill, 
                                RtFloat const **var, 
                                RtFloat const **radius=NULL) const = 0;
    virtual RixSCDetail GetPrimVar(char const *name, RtFloat2 fill, 
                                RtFloat2 const **var, 
                                RtFloat const **radius=NULL) const = 0;
    virtual RixSCDetail GetPrimVar(char const *name, RtFloat3 fill, 
                                RtFloat3 const **var, 
                                RtFloat const **radius=NULL) const = 0;
    virtual RixSCDetail GetPrimVar(char const *name, 
                                RtConstString **var) const = 0;
    /// This variant of GetPrimVar produces bivariate derivatives of an 
    /// arbitrary primvar across the surface measured with respect to u and v.
    /// This function is useful in unusual geometric supersampling conditions
    /// and for bump mapping. The simpler variant is preferred over this
    /// method unless the special features are required.
    virtual RixSCDetail GetPrimVar(char const *name, 
                                RtFloat2 const **var,
                                RtFloat const **dXdu, 
                                RtFloat const **dYdu, 
                                RtFloat const **dXdv, 
                                RtFloat const **dYdv) const = 0;

    /// SetPrimVar: useful for changing state on mutable shading contexts
    /// for consumption by upstream pattern-graph nodes.
    virtual void SetPrimVar(char const *name,  RixSCDetail d,
                            RtFloat *var, RtFloat *radius) = 0;
    virtual void SetPrimVar(char const *name,  RixSCDetail d,
                            RtFloat2 *var, RtFloat *radius) = 0;
    virtual void SetPrimVar(char const *name, RixSCDetail d,
                            RtFloat3 *var, RtFloat *radius) = 0;
    virtual void SetPrimVar(char const *name,  RixSCDetail d,
                            RtString *var) = 0;

    enum TransformInterpretation
    {
        k_AsPoints,
        k_AsVectors,
        k_AsNormals
    };

    /// Transform an array of RtFloat3 (and optional radius) the same 
    /// size as the numPts in the RixShadingContext. The type of 
    /// transformation is specified with TransformInterpretation.
    /// If the call is successful it will return 0.
    virtual int Transform(TransformInterpretation interp,
                          char const *fromSpace, char const *toSpace,
                          RtFloat3 *var, RtFloat *radius = NULL) const = 0;

    /// Return an array of matrices numPts in size that represents the
    /// transformation from "fromSpace" to "toSpace". If the transformation
    /// is time varying, the numMatrices returned will be the same as
    /// numPts in the RixShadingContext. If the transformation is uniform, 
    /// numMatrices will be set to 1. Zero is returned on success.
    virtual int GetTransform(char const *fromSpace, char const *toSpace,
                        RtMatrix4x4 const **matrix, int *numMatrices) const = 0;

    /// Create a context that can be mutated (implements SetBuiltinVar) for
    /// the purposes of super sampling a pattern network. The mutable context
    /// is created in the Bxdf memory of its parent context and does not need
    /// to be released. It will be automatically reclaimed when its parent
    /// context is released.
    virtual RixShadingContext *CreateMutableContext() const = 0;

    /// GetPrimarContext returns a refererence to the (immutable) primary 
    /// shading context. Only in a case where the caller is operating on 
    /// a mutable context created by a downstream node should the returned 
    /// value differ from the invoking ShadingContext.
    virtual RixShadingContext const *GetPrimaryContext() const = 0;
    
    /// EvalParam
    ///
    /// Id-based parameter evaluation captures the data flow through
    /// graph of connected RixPattern and RixBxdf nodes.
    ///
    /// A parameter can be constant or computed.  Calls to the Eval
    /// method of non-constant parameters may trigger function evaluation.
    /// Parameter values may be cached by the renderer for the duration of
    /// an execution context (see RixBxdf Begin/End).
    ///
    /// Calls to EvalParam must fill an entire ShadingContext of values.
    /// The exception to this rule is for RixBxdf composition where
    /// a RixBxdf may be obtained. In that case, the 'driver' Bxdf
    /// is expected to distribute Begin/Eval/Generate/End messages
    /// to subservient Bxdf instances.
    ///
    /// Parameter evaluation:
    /// Bxdfs and Patterns invoke EvalParam to sample their inputs.
    /// Since inputs may or may not obtain values from upstream,
    /// the detail, obtained via GetParamInfo, can be consulted to 
    /// hoist expensive computations out of per-point loops. Again, 
    /// caller is expected to know the type of its parameters.  
    /// If the optional EvalParam parameter, promoteToVarying is true, 
    /// then the detail of the result is guaranteed to be k_RixSCVarying 
    /// but the returned detail will be that associated with the 
    /// actual connection state. EvalParam works for array elements 
    /// as well as simple parameters. In the simple-case, set arrayindex 
    /// to -1. Result is const and should usually not be overwritten by
    /// by caller.. It's common for Bxdf's to wish to conform (clamp) their 
    /// inputs to reasonable ranges and this can be done only in bxdf nodes
    /// and only by const_cast-ing. If a value can't be obtained via
    /// the network nor the Ri parameterlist, we fill the result with
    /// the default value provided.  If the dflt value isn't provided
    /// we return RixSCInvalidDetail.
    virtual RixSCDetail EvalParam(RtInt id, RtInt arrayindex,
                                  RtInt const ** result, 
                                  RtInt const *dflt=NULL,
                                  bool promoteToVarying=false) const = 0;
    virtual RixSCDetail EvalParam(RtInt id, RtInt arrayindex, 
                                  RtFloat const ** result, 
                                  RtFloat const *dflt=NULL,
                                  bool promoteToVarying=false) const = 0;
    virtual RixSCDetail EvalParam(RtInt id, RtInt arrayindex,
                                  RtColorRGB const ** result, 
                                  RtColorRGB const *dflt=NULL,
                                  bool promoteToVarying=false) const = 0;
    virtual RixSCDetail EvalParam(RtInt id, RtInt arrayindex,
                                  RtFloat3 const ** result, 
                                  RtFloat3 const *dflt=NULL,
                                  bool promoteToVarying=false) const = 0;
    virtual RixSCDetail EvalParam(RtInt id, RtInt arrayindex,
                                  RtMatrix4x4 const ** result, 
                                  RtMatrix4x4 const *dflt=NULL,
                                  bool promoteToVarying=false) const = 0;
    virtual RixSCDetail EvalParam(RtInt id, RtInt arrayindex, 
                                  RtConstString** result, 
                                  RtConstString *dflt=NULL,
                                  bool promoteToVarying=false) const = 0;
    virtual RixSCDetail EvalParam(RtInt id, RtInt arrayindex,
                                  RixBxdfFactory** result,
                                  RixBxdfFactory *dflt=NULL,
                                  bool promoteToVarying=false) const = 0;

    enum MemCategory
    {
        k_BxdfMem,
        k_PatternMem
    };

    /// EvalAnCopyParam:
    /// Templated convenience routine for callers who need to modify 
    /// input parameters. Use with care as it incurs an additional 
    /// memory allocation and memcpy. NB: only a subset of types 
    /// produced meaningfully writable results. RtConstStrings, 
    /// RixBxdfFactory are not among them.
    template <class T>
    RixSCDetail EvalAndCopyParam(RtInt id, RtInt arrayindex,
                                T ** result, 
                                T const *dflt=NULL,
                                bool promoteToVarying=false,
                                MemCategory mcat=k_BxdfMem) const
    {
        T const *constResult;
        RixSCDetail d = EvalParam(id, arrayindex, &constResult, dflt);
        switch(d)
        {
        case k_RixSCVarying:
            *result = (T *) Allocate(this->numPts, sizeof(T), mcat);
            memcpy(*result, constResult, this->numPts*sizeof(T));
            break;
        case k_RixSCUniform:
            if(promoteToVarying)
            {
                *result = (T *) Allocate(this->numPts, sizeof(T), mcat);
                std::fill_n(*result, this->numPts, constResult[0]);
            }
            else 
            {
                *result = (T *) Allocate(1, sizeof(T), mcat);
                (*result)[0] = constResult[0];
            }
            break;
        default:
            *result = 0x0;
            break;
        }
        return d;
    }

    /// GetParamId maps a string name to a more efficient integer reference.
    /// The paramid may be negative to support dynamic inputs.  Non-negative 
    /// values are indices into the parameter table, while negative values 
    /// are interpretted as indices into the parameterlist of a RIB instance.
    /// Returns 0 on success, returns nonzero if named parameter is not found.
    virtual RtInt GetParamId(char const *name, RtInt *paramid) const = 0; 

    /// GetParamInfo returns additional detail about the parameter. It's
    /// primary use is during pattern-graph execution to determine
    /// connectivity or dynamic array sizes. Returns 0 on success, nonzero
    /// on failure.
    virtual RtInt GetParamInfo(RtInt paramid, RixSCType *type,
                              RixSCConnectionInfo *cinfo, 
                              int *arraylength=NULL) const = 0;

    /// This version of GetParamInfo is a convenience for use-cases
    /// where a bool notion of connection is sufficient.
    RtInt GetParamInfo(RtInt paramid, RixSCType *type,
                      bool *isconnected, int *arraylength=NULL) const
    {
        RixSCConnectionInfo cinfo;
        int err = GetParamInfo(paramid, type, &cinfo, arraylength);
        if(isconnected)
            *isconnected = (cinfo == k_RixSCNetworkValue);
        return err;
    }

    /// GetNearestHits: traces rays to determine the nearest hit
    /// in the given direction. Both arrays must be at least numRays long.
    /// Misses are indicated in the RtHitPoint via hits[i].dist == 0.
    /// An optional trace subset can be provided to further constrain
    /// objects considered. Clients should include RixIntegrator.h
    /// for the definition of RtRayGeometry and RtHitPoint structs.
    virtual void GetNearestHits(RtInt numRays, RtRayGeometry const *rays,
                        RtHitPoint *hits, char const *subset=NULL) const = 0;

    /// GetLightEmission: returns the sampled *emission* associated
    /// with the shading points. Nonzero return values are only expected
    /// if the shading context is asssociated with a direct light source.
    /// This should not be confused with the results of the LocalEmission
    /// of a Bsdf, but might overlap as with PxrLightEmission.
    virtual void GetLightEmission(RtColorRGB *e) const = 0;

    /// Allocate:
    /// fast memory allocation support from a memory pool tailored to
    /// Pattern and Bxdf plugins. Memory allocated via this interface
    /// is managed (freed) by RixShadingContext according to the lifetime
    /// requirements of the associated MemCategory. As with many custom
    /// memory allocation schemes, clients should use "placement new"
    /// and not rely on invocation of a destructor.  RixAlloca can
    /// be used for intra-procedure dynamic memory allocation.
    virtual void *Allocate(size_t n, size_t size, MemCategory m) const = 0;

    ///
    /// New is a utility (fully inlined) non-virtual method to
    /// assist with tedious memory allocation tasks. Note that
    /// class-constructor methods may be run on array entries.
    /// This cost should be carefully considered for high 
    /// performance requirements.
    ///
    template <class T>
    T *New(size_t nObjs, MemCategory cat=k_BxdfMem) const
    {
        T *mem = static_cast<T*>(Allocate(nObjs, sizeof(T), cat));
        return new (mem) T[nObjs];
     }

    ///
    /// Allocator is a utility (fully inlined) class to assist with
    /// tedious memory pool allocations. Uses templates to support the
    /// variety of atomic datatypes. Refer to above comments on Allocate 
    /// for destructor policies.
    ///
    /// Usage: 
    ///   RixShadingContext::Allocator m(sCtx);
    ///   RtFloat *scmem = m.Allocate<RtFloat>(n); // default lifetime
    ///   RtFloat *smem = m.AllocForBxdf<RtFloat>(n);
    ///
    class Allocator
    {
    public:
        Allocator(RixShadingContext const *sctx) : m_sctx(sctx) {}
        template <typename T>
        T *Allocate(RtInt num)
        {
            if(num == 0) return NULL;
            return (T *) m_sctx->Allocate(num, sizeof(T), k_BxdfMem);
        }
        template <typename T>
        T *AllocFor(MemCategory memcat, RtInt num)
        {
            if(num == 0) return NULL;
            return (T *) m_sctx->Allocate(num, sizeof(T), memcat);
        }
        template <typename T>
        T *AllocForVolume(RtInt num)
        {
            // currently the memory-pool lifetime of volumes matches
            // that of Bxdf.
            if(num == 0) return NULL;
            return (T *) m_sctx->Allocate(num, sizeof(T), k_BxdfMem);
        }
        template <typename T>
        T *AllocForBxdf(RtInt num)
        {
            if(num == 0) return NULL;
            return (T *) m_sctx->Allocate(num, sizeof(T), k_BxdfMem);
        }
        template <typename T>
        T *AllocForPattern(RtInt num)
        {
            if(num == 0) return NULL;
            return (T *) m_sctx->Allocate(num, sizeof(T), k_PatternMem);
        }

    private:
        RixShadingContext const *m_sctx;
    };

protected:
    virtual ~RixShadingContext() {}
};

#endif
